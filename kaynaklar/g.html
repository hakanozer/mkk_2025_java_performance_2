<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>ğŸš€ Spring Boot 3.5 REST API iÃ§in Performans OptimizasyonlarÄ±</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f9; color: #333; }
        .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { color: #0056b3; border-bottom: 3px solid #0056b3; padding-bottom: 10px; text-align: center; }
        h2 { color: #d9534f; margin-top: 25px; border-left: 5px solid #d9534f; padding-left: 10px; }
        h3 { color: #5cb85c; margin-top: 15px; }
        .importance { background-color: #e6f7ff; border-left: 5px solid #337ab7; padding: 10px; margin-bottom: 15px; border-radius: 4px; }
        .example { background-color: #f9f9f9; border: 1px solid #ddd; padding: 15px; margin-top: 10px; border-radius: 4px; overflow-x: auto; }
        code {  padding: 2px 4px; border-radius: 3px; font-family: Consolas, monospace; }
        pre { background-color: #272822; color: #f8f8f2; padding: 15px; border-radius: 5px; overflow-x: auto; }
        strong { color: #337ab7; }
        .topic-group { margin-bottom: 30px; padding: 15px; border: 1px dashed #ccc; border-radius: 8px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ Java Performans & Tuning - REST API OdaklÄ± Ä°puÃ§larÄ±</h1>

        <div class="topic-group">
            <h2>1ï¸âƒ£ JVM YapÄ±sÄ± & Performans Temelleri</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Bir Spring Boot uygulamasÄ±nÄ±n temel Ã§alÄ±ÅŸma prensibini anlamak, <strong>CPU ve bellek kullanÄ±mÄ±nÄ±n</strong> en alt seviyede nasÄ±l yÃ¶netildiÄŸini gÃ¶rmeyi saÄŸlar. Ã–zellikle <strong>JIT Compiler optimizasyonlarÄ±</strong> (<code>method inlining</code>, <code>escape analysis</code>) ile derleme aÅŸamasÄ±nda performansÄ± artÄ±racak kararlar verilir, bu da API'nin yanÄ±t sÃ¼resini (latency) direkt etkiler.</p>
            </div>
            <h3>Basit Ã–rnek: JIT iÃ§in Loop Optimizasyonu</h3>
            <div class="example">
                <p>Basit bir <code>for</code> dÃ¶ngÃ¼sÃ¼nÃ¼n JIT tarafÄ±ndan nasÄ±l optimize edildiÄŸini kod dÃ¼zeyinde gÃ¶rmek zordur, ancak yÃ¼ksek iterasyonlu dÃ¶ngÃ¼lerde JIT'in <strong>Loop Unrolling</strong> gibi tekniklerle performansÄ± artÄ±rdÄ±ÄŸÄ±nÄ± bilmek gerekir.</p>
                <pre><code>// JIT, bu tÃ¼r yoÄŸun dÃ¶ngÃ¼leri donanÄ±m seviyesinde daha hÄ±zlÄ± Ã§alÄ±ÅŸacak ÅŸekilde optimize eder.
long sum = 0;
for (int i = 0; i < 1_000_000; i++) {
    sum += i;
}</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>2ï¸âƒ£ Garbage Collector Derinlemesine</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> <strong>Garbage Collector (GC)</strong>, bellek sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler ve kullanÄ±lmayan nesneleri temizler. Ancak, bu sÃ¼reÃ§ler <strong>"Stop-The-World" (STW)</strong> duraklamalarÄ±na neden olabilir. Ã–zellikle <strong>G1GC'yi</strong> (Spring Boot varsayÄ±lanÄ±) optimize etmek, yÃ¼ksek trafikli REST API'lerinde <strong>dÃ¼ÅŸÃ¼k latency</strong> ve tutarlÄ± yanÄ±t sÃ¼releri iÃ§in kritiktir.</p>
            </div>
            <h3>Basit Ã–rnek: G1GC iÃ§in Tuning</h3>
            <div class="example">
                <p>Uygulama baÅŸlatma sÄ±rasÄ±nda GC duraklama sÃ¼relerini kontrol altÄ±na almak iÃ§in temel JVM argÃ¼manlarÄ±:</p>
                <pre><code>java -Xms2g -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=100 -jar my-app.jar</code></pre>
                <p>Bu, G1GC'nin <strong>100 milisaniye'den uzun</strong> duraklamalarÄ± Ã¶nceliklendirmesini saÄŸlar.</p>
            </div>
        </div>

        <div class="topic-group">
            <h2>3ï¸âƒ£ Java Memory Tuning & Profiling Teknikleri</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Performans sorunlarÄ±nÄ±n Ã§oÄŸu **bellek sÄ±zÄ±ntÄ±larÄ± (Memory Leak)** veya **thread tÄ±kanÄ±klÄ±klarÄ±ndan (Deadlock/Starvation)** kaynaklanÄ±r. <strong>JFR, JMC</strong> ve <strong>Flame Graph</strong> analizi gibi araÃ§lar, canlÄ± sistemlerde bu tÃ¼r gizli ve karmaÅŸÄ±k darboÄŸazlarÄ± (bottlenecks) **minimal overhead** ile tespit etmenin tek yoludur.</p>
            </div>
            <h3>Basit Ã–rnek: Thread Dump Alma</h3>
            <div class="example">
                <p>Uygulama yÃ¼ksek CPU kullanÄ±rken, mevcut thread durumunu analiz etmek iÃ§in kullanÄ±lÄ±r:</p>
                <pre><code># SÃ¼reci bul
jps
# Thread dump al (3456 PID'li uygulama iÃ§in)
jstack 3456 > thread-dump.txt</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>4ï¸âƒ£ Java Collections & Data Structures Performans Analizi</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> DoÄŸru koleksiyon yapÄ±sÄ±nÄ±n seÃ§ilmesi, Ã¶zellikle yÃ¼ksek trafikli API'lerdeki <strong>veri eriÅŸim ve manipÃ¼lasyonunun</strong> performansÄ±nÄ± direkt olarak saniyenin altÄ±ndaki (sub-second) seviyelerde etkiler. YanlÄ±ÅŸ koleksiyon kullanÄ±mÄ± (Ã¶rneÄŸin, gereksiz senkronizasyon), **Contention** yaratÄ±r.</p>
            </div>
            <h3>Basit Ã–rnek: ConcurrentHashMap KullanÄ±mÄ±</h3>
            <div class="example">
                <p>Birden Ã§ok thread'in aynÄ± anda eriÅŸtiÄŸi bir cache veya sayaÃ§ yapÄ±sÄ±nda <code>Hashtable</code> yerine **daha dÃ¼ÅŸÃ¼k Contention** saÄŸlayan <code>ConcurrentHashMap</code> kullanÄ±lÄ±r:</p>
                <pre><code>// Thread-safe ve daha yÃ¼ksek performanslÄ±
private final ConcurrentHashMap&lt;String, Integer> requestCounter = new ConcurrentHashMap<>();

public void increment(String endpoint) {
    requestCounter.compute(endpoint, (k, v) -> (v == null) ? 1 : v + 1);
}</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>5ï¸âƒ£ Multithreading & Concurrency Tuning</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Bir REST API'nin temel amacÄ±, eÅŸzamanlÄ± istekleri hÄ±zlÄ±ca iÅŸlemektir. <strong>Thread Pool'larÄ±n</strong> (Tomcat/Jetty/Netty) ve iÅŸ mantÄ±ÄŸÄ±ndaki <strong>kilit mekanizmalarÄ±nÄ±n</strong> doÄŸru ayarlanmasÄ±, sistemin <strong>eÅŸzamanlÄ± kullanÄ±cÄ± (concurrency)</strong> kapasitesini ve <strong>verimliliÄŸini (throughput)</strong> doÄŸrudan belirler. <strong>Virtual Threads (Project Loom)</strong> ile IO-bound iÅŸ yÃ¼klerinde maliyet dÃ¼ÅŸÃ¼rÃ¼lÃ¼r.</p>
            </div>
            <h3>Basit Ã–rnek: ForkJoinPool (Parallel Stream)</h3>
            <div class="example">
                <p>IO-bound olmayan, yoÄŸun hesaplama gerektiren gÃ¶revlerde <code>parallelStream()</code> kullanÄ±mÄ±:</p>
                <pre><code>// YoÄŸun hesaplama (CPU-bound) iÃ§in uygundur
List&lt;Long> results = longList.parallelStream()
    .map(this::heavyCalculation)
    .collect(Collectors.toList());</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>6ï¸âƒ£ Spring Boot Performans OptimizasyonlarÄ±</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Ã‡erÃ§eveye Ã¶zgÃ¼ optimizasyonlar, **baÅŸlangÄ±Ã§ sÃ¼resini (startup time)**, **hafÄ±za tÃ¼ketimini (memory footprint)** ve **istek iÅŸleme hÄ±zÄ±nÄ±** etkiler. Ã–zellikle <strong>Jackson serialization performance</strong> ve <strong>Tomcat Thread Pool tuning'i</strong>, API'nin gerÃ§ek dÃ¼nyadaki <strong>throughput</strong> ve <strong>latency</strong> metriklerini iyileÅŸtirmenin en hÄ±zlÄ± yollarÄ±ndandÄ±r.</p>
            </div>
            <h3>Basit Ã–rnek: Lazy Initialization</h3>
            <div class="example">
                <p>Uygulama baÅŸlangÄ±cÄ±nÄ± hÄ±zlandÄ±rmak iÃ§in sadece ihtiyaÃ§ duyulduÄŸunda yÃ¼klenen bir Bean:</p>
                <pre><code>@Service
@Lazy // Bean, ilk enjeksiyon anÄ±nda oluÅŸturulur
public class HeavyInitializationService {
    // ...
}</code></pre>
                <p>Basit Ã–rnek: Caffeine Caching</p>
                <pre><code>// Bir serviste basit bir local cache kullanÄ±mÄ±
@Cacheable("products")
public Product getProductById(String id) {
    // VeritabanÄ± sorgusu burada yapÄ±lÄ±r
    return productRepository.findById(id);
}</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>7ï¸âƒ£ Database Tuning (API performansÄ±nÄ± en Ã§ok etkileyen alan)</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Ã‡oÄŸu REST API'de **%80'den fazla yanÄ±t sÃ¼resi** veritabanÄ± iÅŸlemlerinde harcanÄ±r. <strong>HikariCP</strong>'nin doÄŸru ayarlanmasÄ±, **baÄŸlantÄ± bekleme sÃ¼relerini** (connection waiting time) azaltÄ±r. <strong>Hibernate N+1 Problems</strong>'in Ã§Ã¶zÃ¼mÃ¼ ve **DTO Projection** kullanÄ±lmasÄ±, API'nin DB katmanÄ±ndaki yÃ¼kÃ¼ katlanarak dÃ¼ÅŸÃ¼rÃ¼r.</p>
            </div>
            <h3>Basit Ã–rnek: N+1 Sorununu Ã‡Ã¶zmek (Batch Fetching)</h3>
            <div class="example">
                <p>AynÄ± sorgu iÃ§inde iliÅŸkili veriyi de yÃ¼klemek iÃ§in <code>@BatchSize</code> veya JPQL <code>FETCH JOIN</code> kullanÄ±lÄ±r:</p>
                <pre><code>// @Entity Ã¼zerinde
@BatchSize(size = 20) // 1 yerine 20 alt Ã¶ÄŸeyi tek sorguda getirir
@OneToMany(mappedBy = "category")
private List&lt;Product> products;</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>8ï¸âƒ£ Microservice & Cloud Mimarilerde Performans</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> DaÄŸÄ±tÄ±k mimarilerde, tek bir API Ã§aÄŸrÄ±sÄ± birden fazla servisi tetikler. **Service-to-service latency** ve **hata toleransÄ± (Circuit Breaker)** kritik hale gelir. **OpenTelemetry** gibi araÃ§larla <strong>uÃ§tan uca (end-to-end) tracing</strong> yapmak, performans darboÄŸazÄ±nÄ±n hangi serviste olduÄŸunu hÄ±zla tespit etmeyi saÄŸlar.</p>
            </div>
            <h3>Basit Ã–rnek: Circuit Breaker KullanÄ±mÄ± (Resilience4j)</h3>
            <div class="example">
                <p>BaÄŸÄ±mlÄ± bir servisin Ã§Ã¶kmesini Ã¶nlemek ve geri dÃ¶nÃ¼ÅŸ (fallback) saÄŸlamak:</p>
                <pre><code>@Service
public class ExternalService {

    @CircuitBreaker(name = "externalApi", fallbackMethod = "getFallbackData")
    public Data fetchData() {
        // Harici API Ã§aÄŸrÄ±sÄ±
    }

    private Data getFallbackData(Throwable t) {
        // Hata durumunda dÃ¶necek varsayÄ±lan veya Ã¶nbellekteki veri
        return new Data("Default Data");
    }
}</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>9ï¸âƒ£ Benchmarking & Ã–lÃ§me Teknikleri</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> Performans iyileÅŸtirmeleri **kesinlikle Ã¶lÃ§Ã¼lmelidir**. <strong>JMH (Java Microbenchmark Harness)</strong>, Ã¶zellikle kÃ¼Ã§Ã¼k kod bloklarÄ±nÄ±n (collections, algoritmalar) JIT ve GC etkilerinden arÄ±ndÄ±rÄ±lmÄ±ÅŸ, doÄŸru ve gÃ¼venilir bir ÅŸekilde karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ± iÃ§in endÃ¼stri standardÄ±dÄ±r. Bu, rastgele tahminler yerine <strong>veriye dayalÄ± optimizasyon</strong> yapmayÄ± saÄŸlar.</p>
            </div>
            <h3>Basit Ã–rnek: JMH ile Benchmark</h3>
            <div class="example">
                <p><code>@Benchmark</code> ile iki farklÄ± toplama yÃ¶ntemini karÅŸÄ±laÅŸtÄ±rma:</p>
                <pre><code>@Benchmark
public int testArrayList() {
    // ... ArrayList ile iÅŸlem
}

@Benchmark
public int testLinkedList() {
    // ... LinkedList ile iÅŸlem
}</code></pre>
            </div>
        </div>

        <div class="topic-group">
            <h2>ğŸ”Ÿ High-Performance Architectures & Best Practices</h2>
            <div class="importance">
                <p><strong>Ã–nem:</strong> SÄ±nÄ±rlarÄ± zorlayan uygulamalar iÃ§in mimari kararlar gereklidir. <strong>Reactive programming (WebFlux)</strong>, geleneksel senkron (Sync) blocking mimarilere gÃ¶re **Ã§ok daha yÃ¼ksek eÅŸzamanlÄ±lÄ±k** saÄŸlayarak IO-bound iÅŸ yÃ¼klerinde verimi artÄ±rÄ±r. <strong>GraalVM Native Image</strong>, uygulamanÄ±n **baÅŸlangÄ±Ã§ sÃ¼resini saniyenin altÄ±na** dÃ¼ÅŸÃ¼rÃ¼r ve bellek kullanÄ±mÄ±nÄ± bÃ¼yÃ¼k Ã¶lÃ§Ã¼de azaltÄ±r.</p>
            </div>
            <h3>Basit Ã–rnek: WebFlux (Reactive) Controller</h3>
            <div class="example">
                <p>Blocking olmayan (non-blocking) bir API endpoint'i:</p>
                <pre><code>@GetMapping("/products/reactive/{id}")
public Mono&lt;Product> getProductReactive(@PathVariable String id) {
    // Mono/Flux ile async DB eriÅŸimi
    return productService.findById(id);
}</code></pre>
            </div>
        </div>
    </div>
</body>
</html>