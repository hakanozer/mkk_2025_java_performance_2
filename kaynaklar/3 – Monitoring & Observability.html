<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimized Java Development - BÃ¶lÃ¼m 3: Monitoring & Observability</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .highlight {
            background-color: #fffde7;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .performance-impact {
            background-color: #e8f5e9;
            padding: 15px;
            border-left: 4px solid #4caf50;
            margin: 15px 0;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .before, .after {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
        }
        .before {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
        .after {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        .demo-step {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #2196f3;
        }
        .note {
            background-color: #fff3e0;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ff9800;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <h1>Performance Optimized Java Development - BÃ¶lÃ¼m 3: Monitoring & Observability</h1>

    <div class="slide-section">
        <h2>Monitoring vs Observability FarkÄ±</h2>
        
        <div class="highlight">
            <strong>Ã–NEMLÄ° VURGU:</strong> Monitoring, sistemde Ã¶nceden tanÄ±mlanmÄ±ÅŸ metriklerin izlenmesidir. Observability ise sistemin iÃ§ durumunu dÄ±ÅŸarÄ±dan gÃ¶zlemlenebilir hale getirerek, beklenmedik sorunlarÄ±n kÃ¶k nedenlerinin anlaÅŸÄ±labilmesini saÄŸlar.
        </div>

        <div class="performance-impact">
            <strong>PERFORMANS ETKÄ°SÄ°:</strong> Sadece monitoring ile Ã§alÄ±ÅŸan sistemlerde performans sorunlarÄ±nÄ±n kÃ¶k nedeni belirsiz kalabilir ve Ã§Ã¶zÃ¼m sÃ¼resi uzar. Observability ile donatÄ±lmÄ±ÅŸ sistemlerde ise anlÄ±k olarak performans bozukluklarÄ±nÄ±n nedeni tespit edilebilir, bu da Mean Time To Resolution (MTTR) sÃ¼resini dÃ¼ÅŸÃ¼rÃ¼r ve sistem performansÄ±nÄ± uzun vadede artÄ±rÄ±r.
        </div>

        <div class="before-after">
            <div class="before">
                <h3>Ã–NCE</h3>
                <p>Sadece CPU ve Memory kullanÄ±mÄ± izleniyor. Bir API yavaÅŸladÄ±ÄŸÄ±nda, hangi endpoint'in, hangi thread'in, hangi DB sorgusunun neden olduÄŸu bilinmiyor. Sorun giderme sÃ¼resi 4-6 saat.</p>
            </div>
            <div class="after">
                <h3>SONRA</h3>
                <p>Her isteÄŸin trace ID'si, latency daÄŸÄ±lÄ±mÄ±, DB sorgu sÃ¼releri, thread durumlarÄ±, cache hit/miss oranlarÄ± izlenebiliyor. Performans sorunu 5 dakika iÃ§inde lokalize edilip Ã§Ã¶zÃ¼lebiliyor.</p>
            </div>
        </div>
    </div>

    <div class="slide-section">
        <h2>Spring Boot Actuator: Health, Metrics, Thread dump</h2>
        
        <div class="highlight">
            <strong>Ã–NEMLÄ° VURGU:</strong> Spring Boot Actuator, uygulamanÄ±zÄ±n iÃ§ durumunu HTTP endpointleri veya JMX Ã¼zerinden dÄ±ÅŸarÄ±ya aÃ§ar. Production ortamÄ±nda gÃ¼venlik nedeniyle sadece gerekli endpointler aÃ§Ä±lmalÄ± ve yetkilendirme yapÄ±lmalÄ±dÄ±r.
        </div>

        <div class="performance-impact">
            <strong>PERFORMANS ETKÄ°SÄ°:</strong> Actuator endpointleri varsayÄ±lan olarak hafif performans yÃ¼kÃ¼ getirir. Ancak <code>/health</code> endpointi veritabanÄ±, disk, external servis baÄŸlantÄ±larÄ±nÄ± kontrol edecek ÅŸekilde konfigÃ¼re edilirse, her health check isteÄŸi performansÄ± etkileyebilir. Bu nedenle production'da detaylÄ± saÄŸlÄ±k kontrolleri sadece yetkili eriÅŸimler iÃ§in aÃ§Ä±lmalÄ±.
        </div>

        <h3>Temel Actuator Endpointleri</h3>
        <ul>
            <li><code>/actuator/health</code> - Uygulama saÄŸlÄ±k durumu</li>
            <li><code>/actuator/metrics</code> - JVM ve sistem metrikleri</li>
            <li><code>/actuator/threaddump</code> - Thread durumlarÄ± ve deadlock analizi</li>
            <li><code>/actuator/heapdump</code> - Heap dump almak iÃ§in</li>
            <li><code>/actuator/env</code> - Ortam deÄŸiÅŸkenleri</li>
        </ul>

        <div class="code-block">
# application.yml konfigÃ¼rasyonu
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,threaddump,prometheus
  endpoint:
    health:
      show-details: never # production'da 'never' veya 'when_authorized'
    threaddump:
      enabled: true
  metrics:
    enable:
      http:
        server:
          requests: true
</div>

        <div class="before-after">
            <div class="before">
                <h3>Ã–NCE</h3>
                <p>Uygulama yavaÅŸladÄ±ÄŸÄ±nda, thread'lerin ne yaptÄ±ÄŸÄ±nÄ± bilemiyoruz. Thread dump almak iÃ§in JVM komutlarÄ± veya server eriÅŸimi gerekiyor. Sorun tespiti saatler sÃ¼rÃ¼yor.</p>
            </div>
            <div class="after">
                <h3>SONRA</h3>
                <p><code>/actuator/threaddump</code> endpointi ile anlÄ±k olarak tÃ¼m thread'lerin durumu, hangi kodda beklediÄŸi, CPU tÃ¼ketimi gÃ¶rÃ¼lebiliyor. Deadlock veya thread starvation sorunlarÄ± dakikalar iÃ§inde tespit edilebiliyor.</p>
            </div>
        </div>
    </div>

    <div class="slide-section">
        <h2>Micrometer Metrikleri</h2>
        
        <div class="highlight">
            <strong>Ã–NEMLÄ° VURGU:</strong> Micrometer, Spring Boot 2.0+ ile entegre olan vendor-neutral bir metrik facade'idir. Prometheus, Graphite, Datadog gibi birden fazla monitoring sistemine aynÄ± anda metrik gÃ¶nderebilir.
        </div>

        <div class="performance-impact">
            <strong>PERFORMANS ETKÄ°SÄ°:</strong> Micrometer, metrik toplama iÅŸlemini asenkron ve ring buffer tabanlÄ± yaparak minimum performans etkisiyle Ã§alÄ±ÅŸÄ±r. Ancak Ã§ok fazla custom metrik tanÄ±mlamak veya Ã§ok sÄ±k Ã¶lÃ§Ã¼m almak (Ã¶rneÄŸin her milisaniyede) performansÄ± etkileyebilir. Ã–nerilen Ã¶lÃ§Ã¼m aralÄ±ÄŸÄ±: 1-5 saniye.
        </div>

        <h3>Temel Micrometer Metrik Tipleri</h3>
        <ul>
            <li><strong>Counter:</strong> Artan tek yÃ¶nlÃ¼ sayaÃ§lar (Ã¶rneÄŸin toplam istek sayÄ±sÄ±)</li>
            <li><strong>Gauge:</strong> AnlÄ±k deÄŸerler (Ã¶rneÄŸin aktif kullanÄ±cÄ± sayÄ±sÄ±, memory kullanÄ±mÄ±)</li>
            <li><strong>Timer:</strong> SÃ¼re bazlÄ± Ã¶lÃ§Ã¼mler (Ã¶rneÄŸin API response time)</li>
            <li><strong>DistributionSummary:</strong> DaÄŸÄ±lÄ±m bazlÄ± Ã¶lÃ§Ã¼mler (Ã¶rneÄŸin response size)</li>
        </ul>

        <div class="code-block">
// Custom metrik tanÄ±mlama Ã¶rneÄŸi
@Service
public class ProductService {
    
    private final MeterRegistry meterRegistry;
    
    public ProductService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public Product getProductById(Long id) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Product product = productRepository.findById(id)
                .orElseThrow(() -> new ProductNotFoundException(id));
            
            // Ä°ÅŸlem sÃ¼resini Ã¶lÃ§
            sample.stop(Timer.builder("product.service.get.by.id")
                .tag("productId", String.valueOf(id))
                .tag("status", "success")
                .register(meterRegistry));
                
            return product;
        } catch (Exception e) {
            sample.stop(Timer.builder("product.service.get.by.id")
                .tag("productId", String.valueOf(id))
                .tag("status", "error")
                .register(meterRegistry));
            throw e;
        }
    }
}
</div>

        <div class="before-after">
            <div class="before">
                <h3>Ã–NCE</h3>
                <p>Sadece loglarda "Product getirildi" yazÄ±yor. KaÃ§ milisaniye sÃ¼rdÃ¼ÄŸÃ¼, hangi ID'ler iÃ§in yavaÅŸ Ã§alÄ±ÅŸtÄ±ÄŸÄ±, hata oranÄ± bilinmiyor.</p>
            </div>
            <div class="after">
                <h3>SONRA</h3>
                <p>Her product getirme iÅŸleminin sÃ¼resi, baÅŸarÄ±lÄ±/hatalÄ± durumu, hangi ID iÃ§in olduÄŸu Micrometer ile Ã¶lÃ§Ã¼lÃ¼yor. Grafana'da 95. percentile response time, error rate, slowest products gibi detaylÄ± analizler yapÄ±lÄ±yor.</p>
            </div>
        </div>
    </div>

    <div class="slide-section">
        <h2>Prometheus & Grafana Entegrasyonu</h2>
        
        <div class="highlight">
            <strong>Ã–NEMLÄ° VURGU:</strong> Prometheus, pull-based bir metrik toplama sistemidir. UygulamanÄ±zÄ±n <code>/actuator/prometheus</code> endpointinden periyodik olarak metrikleri Ã§eker. Grafana ise bu metrikleri gÃ¶rselleÅŸtirmek iÃ§in kullanÄ±lÄ±r.
        </div>

        <div class="performance-impact">
            <strong>PERFORMANS ETKÄ°SÄ°:</strong> Prometheus'un metrik Ã§ekme sÄ±klÄ±ÄŸÄ± (scrape interval) Ã§ok sÄ±k ayarlanÄ±rsa (Ã¶rneÄŸin 1 saniye), yÃ¼ksek trafikli sistemlerde ekstra yÃ¼k oluÅŸturabilir. Optimal deÄŸer: 15-30 saniye. AyrÄ±ca metriklerin etiket sayÄ±sÄ± Ã§ok fazla olursa, Prometheus'un depolama ve sorgulama performansÄ± dÃ¼ÅŸer.
        </div>

        <h3>Entegrasyon AdÄ±mlarÄ±</h3>
        <ol>
            <li>Spring Boot projeye Micrometer Prometheus dependency ekle</li>
            <li>application.yml'de prometheus endpointini aÃ§</li>
            <li>Prometheus.yml konfigÃ¼rasyon dosyasÄ±nda Spring Boot uygulamasÄ±nÄ± hedef olarak tanÄ±mla</li>
            <li>Grafana'da Prometheus datasource olarak ekle</li>
            <li>Dashboard oluÅŸtur veya Spring Boot iÃ§in hazÄ±r dashboard import et</li>
        </ol>

        <div class="code-block">
<!-- pom.xml -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>

<!-- application.yml -->
management:
  metrics:
    export:
      prometheus:
        enabled: true
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus

# prometheus.yml
scrape_configs:
  - job_name: 'spring-boot-app'
    metrics_path: '/actuator/prometheus'
    scrape_interval: 15s
    static_configs:
      - targets: ['localhost:8080']
</div>

        <div class="note">
            <strong>NOT:</strong> Production ortamÄ±nda Prometheus'un scrape edebileceÄŸi metrik miktarÄ±nÄ± sÄ±nÄ±rlamak iÃ§in aÅŸaÄŸÄ±daki konfigÃ¼rasyon kullanÄ±labilir:
            <div class="code-block">
management:
  metrics:
    enable:
      jvm: true
      http: true
      cache: true
      # AÅŸaÄŸÄ±daki metrikler Ã§ok detaylÄ± olduÄŸu iÃ§in kapatÄ±labilir
      # jdbc: false
      # hibernate: false
            </div>
        </div>
    </div>

    <div class="slide-section">
        <h2>Alert MekanizmalarÄ±</h2>
        
        <div class="highlight">
            <strong>Ã–NEMLÄ° VURGU:</strong> Alert'ler sadece "sistem down" durumlarÄ± iÃ§in deÄŸil, performans bozukluklarÄ±nÄ± erken tespit etmek iÃ§in de konfigÃ¼re edilmelidir. Ã–rneÄŸin 95. percentile response time 2 saniyeyi geÃ§tiÄŸinde alert verilmeli.
        </div>

        <div class="performance-impact">
            <strong>PERFORMANS ETKÄ°SÄ°:</strong> Ä°yi tanÄ±mlanmÄ±ÅŸ alert'ler, performans sorunlarÄ±nÄ±n kullanÄ±cÄ± etkilemeden Ã¶nce tespit edilmesini saÄŸlar. Bu da kullanÄ±cÄ± deneyimini korur ve sistem kaynaklarÄ±nÄ±n verimli kullanÄ±mÄ±nÄ± saÄŸlar. KÃ¶tÃ¼ tanÄ±mlanmÄ±ÅŸ alert'ler ise "alert fatigue" yaratÄ±r ve gerÃ§ek sorunlar gÃ¶zden kaÃ§abilir.
        </div>

        <h3>Temel Alert SenaryolarÄ±</h3>
        <ul>
            <li>HTTP error rate > %5 (5 dakika ortalama)</li>
            <li>95. percentile response time > 2000ms</li>
            <li>JVM memory usage > %85</li>
            <li>CPU usage > %90 (10 dakika sÃ¼reklilik)</li>
            <li>Thread count > 500 (anormal artÄ±ÅŸ)</li>
        </ul>

        <div class="code-block">
# Alert Rules (Prometheus rules.yml)
groups:
- name: spring-boot-alerts
  rules:
  - alert: HighRequestLatency
    expr: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket{application="myapp"}[5m])) by (le)) > 2
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High request latency (instance {{ $labels.instance }})"
      description: "95th percentile response time is above 2s for 5 minutes"

  - alert: HighErrorRate
    expr: sum(rate(http_server_requests_seconds_count{status=~"5..",application="myapp"}[5m])) / sum(rate(http_server_requests_seconds_count{application="myapp"}[5m])) > 0.05
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "High error rate (instance {{ $labels.instance }})"
      description: "HTTP error rate is above 5% for 5 minutes"
</div>
    </div>

    <div class="slide-section">
        <h2>ğŸ’» Demo Senaryosu: End-to-End Performans Ä°zleme</h2>
        
        <div class="demo-step">
            <h3>AdÄ±m 1: /actuator/metrics/http.server.requests ile response time Ã¶lÃ§Ã¼mÃ¼</h3>
            <p>Spring Boot uygulamasÄ±nÄ± Ã§alÄ±ÅŸtÄ±rÄ±n ve aÅŸaÄŸÄ±daki endpointe eriÅŸin:</p>
            <div class="code-block">
GET http://localhost:8080/actuator/metrics/http.server.requests

# Response Ã¶rneÄŸi:
{
  "name": "http.server.requests",
  "description": "Timer of HTTP server requests",
  "baseUnit": "seconds",
  "measurements": [
    { "statistic": "COUNT", "value": 125 },
    { "statistic": "TOTAL_TIME", "value": 45.23 },
    { "statistic": "MAX", "value": 1.45 }
  ],
  "availableTags": [
    { "tag": "exception", "values": ["None"] },
    { "tag": "method", "values": ["GET", "POST"] },
    { "tag": "uri", "values": ["/api/products", "/api/users"] },
    { "tag": "status", "values": ["200", "404"] }
  ]
}
            </div>
            <p>Her bir URI iÃ§in ayrÄ± ayrÄ± performans Ã¶lÃ§Ã¼mÃ¼ yapmak iÃ§in:</p>
            <div class="code-block">
GET http://localhost:8080/actuator/metrics/http.server.requests?tag=uri:/api/products&tag=method:GET

# Bu, sadece GET /api/products isteklerinin metriklerini gÃ¶sterir
            </div>
        </div>

        <div class="demo-step">
            <h3>AdÄ±m 2: Prometheus + Grafana dashboard Ã¼zerinden Spring Boot metrikleri izleme</h3>
            <ol>
                <li>Prometheus'u Docker ile baÅŸlatÄ±n:
                    <div class="code-block">
docker run -d -p 9090:9090 -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus
                    </div>
                </li>
                <li>Grafana'yÄ± Docker ile baÅŸlatÄ±n:
                    <div class="code-block">
docker run -d -p 3000:3000 grafana/grafana
                    </div>
                </li>
                <li>Grafana'ya giriÅŸ yapÄ±n (admin/admin) ve Prometheus'u datasource olarak ekleyin</li>
                <li>Spring Boot iÃ§in hazÄ±r dashboard import edin (ID: 10280 veya 4701)</li>
                <li>Dashboard'da aÅŸaÄŸÄ±daki metrikleri izleyin:
                    <ul>
                        <li>JVM Memory Usage</li>
                        <li>HTTP Request Rate ve Error Rate</li>
                        <li>Response Time Percentiles (50, 90, 95, 99)</li>
                        <li>Thread Count ve CPU Usage</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="demo-step">
            <h3>AdÄ±m 3: JMeter ile load testi yap â†’ Grafana'da gÃ¶zlemle</h3>
            <ol>
                <li>JMeter'i aÃ§Ä±n ve yeni bir Test Plan oluÅŸturun</li>
                <li>Thread Group ekleyin:
                    <ul>
                        <li>Number of Threads: 100</li>
                        <li>Ramp-up period: 10 saniye</li>
                        <li>Loop Count: 100</li>
                    </ul>
                </li>
                <li>HTTP Request ekleyin:
                    <ul>
                        <li>Server Name: localhost</li>
                        <li>Port: 8080</li>
                        <li>Path: /api/products</li>
                    </ul>
                </li>
                <li>View Results Tree ve Summary Report ekleyin</li>
                <li>Testi baÅŸlatÄ±n</li>
                <li>AynÄ± anda Grafana dashboardunu aÃ§Ä±n ve aÅŸaÄŸÄ±daki deÄŸiÅŸiklikleri gÃ¶zlemleyin:
                    <ul>
                        <li>HTTP Request Rate'Ä±n ani yÃ¼kseliÅŸi</li>
                        <li>Response Time'Ä±n nasÄ±l deÄŸiÅŸtiÄŸi (Ã¶zellikle 95. percentile)</li>
                        <li>JVM Memory Usage'Ä±n artÄ±ÅŸÄ± ve GC etkinliÄŸi</li>
                        <li>Thread Count'un artÄ±ÅŸÄ±</li>
                        <li>EÄŸer hata olursa Error Rate grafiÄŸi</li>
                    </ul>
                </li>
                <li>Test bittikten sonra, sistem yÃ¼kÃ¼nÃ¼n dÃ¼ÅŸmesiyle birlikte metriklerin normale dÃ¶nÃ¼p dÃ¶nmediÄŸini gÃ¶zlemleyin</li>
            </ol>
            
            <div class="performance-impact">
                <strong>PERFORMANS ETKÄ°SÄ° GÃ–ZLEMÄ°:</strong> JMeter testi sÄ±rasÄ±nda Grafana'da response time'Ä±n 95. percentile'Ä±nÄ±n 500ms'den 2500ms'ye Ã§Ä±ktÄ±ÄŸÄ±nÄ± gÃ¶zlemlediniz. Bu, sistemin 100 eÅŸzamanlÄ± kullanÄ±cÄ± altÄ±nda performans bozukluÄŸuna uÄŸradÄ±ÄŸÄ±nÄ± gÃ¶sterir. Thread dump analizi ile thread'lerin database connection pool'da beklediÄŸi tespit edildi. Connection pool size artÄ±rÄ±ldÄ±ÄŸÄ±nda, aynÄ± yÃ¼kte response time 600ms seviyesine dÃ¼ÅŸtÃ¼.
            </div>
        </div>

        <div class="note">
            <h3>Ã–ÄŸrencilere Pratik Ã–dev:</h3>
            <p>Ã–ÄŸrencilerden kendi Spring Boot uygulamalarÄ±na aÅŸaÄŸÄ±daki optimizasyonlarÄ± uygulamalarÄ±nÄ± isteyin:</p>
            <ol>
                <li>Actuator endpointlerini gÃ¼venli hale getirin (sadece admin eriÅŸebilsin)</li>
                <li>Ã–zel bir metrik ekleyin (Ã¶rneÄŸin cache hit ratio)</li>
                <li>Prometheus ve Grafana kurulumu yapÄ±n</li>
                <li>Basit bir alert kuralÄ± tanÄ±mlayÄ±n (Ã¶rneÄŸin error rate > %1)</li>
                <li>JMeter ile load testi yapÄ±n ve performans bozukluÄŸunu Grafana'da gÃ¶zlemleyin</li>
                <li>PerformansÄ± artÄ±rmak iÃ§in bir optimizasyon yapÄ±n (cache ekleme, connection pool artÄ±rma vb.) ve etkisini Ã¶lÃ§Ã¼n</li>
            </ol>
        </div>
    </div>

    <div class="slide-section">
        <h2>Ã–zet ve En Ä°yi Uygulamalar</h2>
        
        <div class="highlight">
            <strong>PERFORMANS Ä°Ã‡Ä°N KRÄ°TÄ°K VURGULAR:</strong>
            <ol>
                <li>Observability sadece tooling deÄŸil, sistem mimarisinin bir parÃ§asÄ±dÄ±r. Performans optimizasyonu iÃ§in Ã¶lÃ§Ã¼lebilir olmak ÅŸarttÄ±r.</li>
                <li>Production'da Actuator endpointlerine eriÅŸimi kÄ±sÄ±tlayÄ±n. Sadece gerekli metrikleri toplayÄ±n.</li>
                <li>Metrik etiketlerini dikkatli seÃ§in. Ã‡ok fazla kardinalite (Ã¶rneÄŸin user_id gibi) Prometheus performansÄ±nÄ± dÃ¼ÅŸÃ¼rÃ¼r.</li>
                <li>Alert'leri anlamlÄ± ve actionable olacak ÅŸekilde tanÄ±mlayÄ±n. "Sistem yavaÅŸladÄ±" deÄŸil, "GET /api/products 95. percentile response time 2s'yi aÅŸtÄ±" gibi spesifik alertler.</li>
                <li>Load testlerini dÃ¼zenli yapÄ±n ve performans eÄŸilimlerini takip edin. BugÃ¼n Ã§alÄ±ÅŸan sistem, yarÄ±n Ã§Ã¶kebilir.</li>
            </ol>
        </div>

        <div class="performance-impact">
            <strong>SONUÃ‡ OLARAK PERFORMANS KAZANIMI:</strong> Observability araÃ§larÄ± ile donatÄ±lmÄ±ÅŸ bir Spring Boot uygulamasÄ±nda:
            <ul>
                <li>Mean Time To Detect (MTTD) %90 azalÄ±r</li>
                <li>Mean Time To Resolution (MTTR) %70 azalÄ±r</li>
                <li>Proaktif optimizasyonlar ile response time %40 iyileÅŸtirilebilir</li>
                <li>Kaynak israfÄ± (CPU, Memory) %30 azaltÄ±labilir</li>
                <li>KullanÄ±cÄ± deneyimi (UX) Ã¶lÃ§Ã¼lebilir ÅŸekilde iyileÅŸtirilir</li>
            </ul>
        </div>
    </div>
</body>
</html>