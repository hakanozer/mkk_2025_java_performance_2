<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BÃ¶lÃ¼m 6 â€“ Distributed Caching & In-Memory Data Grids</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-title {
            font-weight: bold;
            color: #e74c3c;
            font-size: 1.3em;
        }
        .important {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .performance-impact {
            background-color: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .before, .after {
            flex: 1;
            padding: 20px;
            border-radius: 8px;
        }
        .before {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        .after {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        .demo-step {
            background-color: #e8f4f8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            border-left: 4px solid #007acc;
        }
        .tool-tip {
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

    <h1>BÃ¶lÃ¼m 6 â€“ Distributed Caching & In-Memory Data Grids</h1>

    <h2 class="slide-title">Cache Ã‡eÅŸitleri: Local vs Distributed</h2>

    <p><strong>Local Cache:</strong> UygulamanÄ±n kendi belleÄŸinde tutulan, sadece o instanceâ€™a Ã¶zel cache katmanÄ±dÄ±r. Ã–rnek: Caffeine, Ehcache (local modda).</p>

    <p><strong>Distributed Cache:</strong> Birden fazla uygulama instanceâ€™Ä± arasÄ±nda paylaÅŸÄ±lan, network Ã¼zerinden eriÅŸilen cache katmanÄ±dÄ±r. Ã–rnek: Redis, Hazelcast, Memcached.</p>

    <div class="important">
        <strong>â— Vurgu:</strong> Local cache, network gecikmesi olmadÄ±ÄŸÄ± iÃ§in Ã§ok hÄ±zlÄ±dÄ±r ama veri tutarlÄ±lÄ±ÄŸÄ± (consistency) ve paylaÅŸÄ±labilirlik aÃ§Ä±sÄ±ndan sÄ±nÄ±rlÄ±dÄ±r. Distributed cache, Ã¶lÃ§eklenebilirlik ve yÃ¼ksek eriÅŸilebilirlik saÄŸlar ama network maliyeti vardÄ±r.
    </div>

    <div class="performance-impact">
        <strong>âš¡ Performans Etkisi:</strong> 
        <ul>
            <li><strong>Local Cache:</strong> 1-5 mikrosaniye eriÅŸim sÃ¼resi. GC baskÄ±sÄ± olabilir.</li>
            <li><strong>Distributed Cache:</strong> 0.5-5 milisaniye eriÅŸim sÃ¼resi (network + serialization). GC etkisi az ama network bottleneck olabilir.</li>
        </ul>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>Ã–NCE: Local Cache ile Tek Instance</h3>
            <p>Her kullanÄ±cÄ± isteÄŸi aynÄ± JVM'de cacheâ€™lenir. Ã–lÃ§eklenme yok. Sunucu yeniden baÅŸlatÄ±ldÄ±ÄŸÄ±nda cache silinir.</p>
            <p><strong>Performans:</strong> Ã‡ok hÄ±zlÄ± ama tek nokta, tek sunucu baÄŸÄ±mlÄ±lÄ±ÄŸÄ±.</p>
        </div>
        <div class="after">
            <h3>SONRA: Distributed Cache ile Multi-Instance</h3>
            <p>3 adet Spring Boot instance, Redis Ã¼zerinden ortak cache paylaÅŸÄ±r. YÃ¼k dengeleme ile Ã¶lÃ§eklenebilir mimari.</p>
            <p><strong>Performans:</strong> Network gecikmesi eklenir ama sistem Ã§Ã¶kse bile cache korunur ve diÄŸer instanceâ€™lar devam eder.</p>
        </div>
    </div>

    <h2 class="slide-title">Redis & Hazelcast Mimarisi</h2>

    <p><strong>Redis:</strong> Anahtar-deÄŸer deposu. Tek-threaded, in-memory, disk persistence opsiyonel. Master-Slave replikasyon ve Redis Cluster ile yatay Ã¶lÃ§eklenebilir.</p>

    <p><strong>Hazelcast:</strong> In-Memory Data Grid. Java nesnelerini daÄŸÄ±tÄ±k ÅŸekilde tutar. Peer-to-peer mimari, her node hem client hem server olabilir. Map, Queue, Lock gibi yapÄ±larÄ± native destekler.</p>

    <div class="important">
        <strong>â— Vurgu:</strong> 
        <ul>
            <li>Redis: Basit, hÄ±zlÄ±, geniÅŸ dil desteÄŸi. Veri yapÄ±sÄ± sÄ±nÄ±rlÄ± (string, hash, list, set, sorted set).</li>
            <li>Hazelcast: Java-native, kompleks nesneleri doÄŸrudan depolayabilir, daÄŸÄ±tÄ±k hesaplama ve eventing destekler.</li>
        </ul>
    </div>

    <div class="performance-impact">
        <strong>âš¡ Performans Etkisi:</strong> 
        <ul>
            <li><strong>Redis:</strong> Network + serialization maliyeti. Basit veri tipleri iÃ§in optimize.</li>
            <li><strong>Hazelcast:</strong> Java serileÅŸtirme maliyeti yÃ¼ksek olabilir (Ã¶zellikle Java Serialization kullanÄ±lÄ±rsa). Kryo veya Protobuf ile optimize edilebilir.</li>
        </ul>
    </div>

    <h2 class="slide-title">Serialization/Deserialization Maliyeti</h2>

    <p>Java nesnelerinin byte dizisine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi (serialize) ve geri yÃ¼klenmesi (deserialize) CPU ve bellek tÃ¼ketir. Ã–zellikle bÃ¼yÃ¼k nesnelerde bu maliyet belirginleÅŸir.</p>

    <div class="important">
        <strong>â— Vurgu:</strong> Default Java Serialization yavaÅŸ ve aÄŸ trafiÄŸi aÃ§Ä±sÄ±ndan verimsizdir. Performans kritik sistemlerde mutlaka alternatif serializer kullanÄ±lmalÄ±dÄ±r.
    </div>

    <div class="performance-impact">
        <strong>âš¡ Performans Etkisi:</strong> 
        <ul>
            <li>Java Serialization: 100-500 ms arasÄ± bÃ¼yÃ¼k nesneler iÃ§in.</li>
            <li>Kryo: 10-50 ms arasÄ± (10x daha hÄ±zlÄ±).</li>
            <li>Protobuf: 5-30 ms arasÄ± + en az aÄŸ trafiÄŸi.</li>
        </ul>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>Ã–NCE: Default Java Serialization</h3>
            <div class="code-block">
// application.properties
spring.cache.hazelcast.config=classpath:hazelcast.xml

// Hazelcast config (default serialization)
<serialization>
    <serializable-factories/>
</serialization>
            </div>
            <p><strong>Performans:</strong> 10.000 nesne serialize iÃ§in ~450ms</p>
        </div>
        <div class="after">
            <h3>SONRA: Kryo ile Serialization</h3>
            <div class="code-block">
// Hazelcast config with Kryo
<serialization>
    <serializers>
        <serializer type-class="com.example.Product" 
                    class-name="com.example.KryoSerializer"/>
    </serializers>
</serialization>

// KryoSerializer.java
public class KryoSerializer implements StreamSerializer<Object> {
    @Override
    public void write(ObjectDataOutput out, Object obj) throws IOException {
        Kryo kryo = new Kryo();
        Output output = new Output((OutputStream) out);
        kryo.writeClassAndObject(output, obj);
        output.flush();
    }
    // ... read method
}
            </div>
            <p><strong>Performans:</strong> AynÄ± nesne iÃ§in ~45ms â†’ <strong>%90 performans artÄ±ÅŸÄ±!</strong></p>
        </div>
    </div>

    <h2 class="slide-title">Eviction Policy & Memory Impact</h2>

    <p>Cache bellek dolunca hangi verilerin atÄ±lacaÄŸÄ±nÄ± belirleyen stratejilerdir.</p>

    <ul>
        <li><strong>LRU (Least Recently Used):</strong> En az kullanÄ±lan veriyi atar.</li>
        <li><strong>LFU (Least Frequently Used):</strong> En az eriÅŸilen veriyi atar.</li>
        <li><strong>MAX_SIZE / MAX_IDLE_TIME:</strong> Boyut veya zaman bazlÄ± eviction.</li>
    </ul>

    <div class="important">
        <strong>â— Vurgu:</strong> YanlÄ±ÅŸ eviction policy, cache hit ratioâ€™yu dÃ¼ÅŸÃ¼rÃ¼r â†’ cacheâ€™in faydasÄ± yok olur. Bellek baskÄ±sÄ± artar, GC sÄ±klÄ±ÄŸÄ± artar.
    </div>

    <div class="performance-impact">
        <strong>âš¡ Performans Etkisi:</strong> 
        <ul>
            <li>LRU: Genelde en iyi performansÄ± verir (cache hit ratio %70-90).</li>
            <li>LFU: Uzun vadeli eriÅŸim paternlerinde etkili.</li>
            <li>YanlÄ±ÅŸ policy: Cache hit ratio %30â€™a dÃ¼ÅŸebilir â†’ DB sorgularÄ± artar â†’ sistem yavaÅŸlar.</li>
        </ul>
    </div>

    <h2 class="slide-title">Benchmark YÃ¶ntemleri</h2>

    <p>Cache performansÄ±nÄ± Ã¶lÃ§mek iÃ§in:</p>
    <ul>
        <li><strong>Response Time:</strong> Ortalama, median, %95, %99 latency.</li>
        <li><strong>Throughput:</strong> Saniyedeki istek sayÄ±sÄ± (RPS).</li>
        <li><strong>Cache Hit Ratio:</strong> Cacheâ€™ten servis edilen istek / toplam istek.</li>
        <li><strong>Memory Usage:</strong> Heap ve off-heap bellek tÃ¼ketimi.</li>
        <li><strong>GC Overhead:</strong> Garbage Collector sÃ¼resi ve sÄ±klÄ±ÄŸÄ±.</li>
    </ul>

    <div class="important">
        <strong>â— Vurgu:</strong> Benchmark sÄ±rasÄ±nda gerÃ§ekÃ§i veri seti ve yÃ¼k paterni kullanÄ±n. â€œHello Worldâ€ Ã¶rneÄŸiyle yapÄ±lan benchmark aldatÄ±cÄ±dÄ±r.
    </div>

    <div class="performance-impact">
        <strong>âš¡ Performans Etkisi:</strong> 
        <p>DoÄŸru benchmark, cache katmanÄ±nÄ±n sisteme katkÄ±sÄ±nÄ± net gÃ¶sterir. Ã–rneÄŸin: Redis entegrasyonu sonrasÄ± ortalama response time 200ms â†’ 45msâ€™e dÃ¼ÅŸebilir.</p>
    </div>

    <h2 class="slide-title">ğŸ’» Demo Senaryosu: Spring Boot 3.5.5 + IntelliJ IDEA Ultimate</h2>

    <div class="demo-step">
        <h3>AdÄ±m 1: Spring Cache Abstraction ile Redis Entegrasyonu</h3>
        <div class="code-block">
// pom.xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

// application.properties
spring.redis.host=localhost
spring.redis.port=6379
spring.cache.type=redis

// ProductService.java
@Service
@CacheConfig(cacheNames = "products")
public class ProductService {
    
    @Cacheable(key = "#id")
    public Product findById(Long id) {
        // DB call - expensive operation
        return productRepository.findById(id).orElse(null);
    }
    
    @CacheEvict(key = "#product.id")
    public void updateProduct(Product product) {
        productRepository.save(product);
    }
}
        </div>
        <p class="tool-tip">ğŸ’¡ IntelliJ IDEA Ultimate: Spring Boot desteÄŸi, Redis plugin ile cache iÃ§eriÄŸini gÃ¶rsel olarak izleyebilirsiniz.</p>
    </div>

    <div class="demo-step">
        <h3>AdÄ±m 2: Hazelcast Cluster Kurulumu</h3>
        <div class="code-block">
// pom.xml
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-spring</artifactId>
</dependency>

// hazelcast.yaml (src/main/resources)
hazelcast:
  network:
    join:
      multicast:
        enabled: true
      tcp-ip:
        enabled: false
  map:
    products:
      time-to-live-seconds: 300
      max-idle-seconds: 60
      eviction:
        size: 10000
        max-size-policy: PER_NODE
        eviction-policy: LRU

// Application.java
@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
    
    @Bean
    public Config hazelcastConfig() {
        Config config = new Config();
        config.setNetworkConfig(new NetworkConfig().setPort(5701));
        return config;
    }
}
        </div>
        <p class="tool-tip">ğŸ’¡ IntelliJ IDEA Ultimate: Docker entegrasyonu ile 3 adet Hazelcast nodeâ€™u docker-compose ile kolayca ayaÄŸa kaldÄ±rÄ±labilir.</p>
    </div>

    <div class="demo-step">
        <h3>AdÄ±m 3: JMeter ile Benchmark â†’ Redis vs Hazelcast Response Time KÄ±yaslamasÄ±</h3>
        <ol>
            <li>JMeterâ€™Ä± aÃ§Ä±n ve yeni bir â€œTest Planâ€ oluÅŸturun.</li>
            <li>Thread Group: 100 kullanÄ±cÄ±, ramp-up 10 saniye, loop 100.</li>
            <li>HTTP Request: GET http://localhost:8080/api/products/1</li>
            <li>Listener: View Results Tree + Summary Report + Aggregate Report ekleyin.</li>
            <li>Ã–nce Redis cache aktifken testi Ã§alÄ±ÅŸtÄ±rÄ±n.</li>
            <li>Sonra Hazelcast aktifken testi Ã§alÄ±ÅŸtÄ±rÄ±n.</li>
            <li>Ä°ki senaryonun â€œAverage Response Timeâ€ ve â€œThroughputâ€ deÄŸerlerini karÅŸÄ±laÅŸtÄ±rÄ±n.</li>
        </ol>
        <div class="code-block">
# Ã–rnek JMeter SonuÃ§larÄ± (1000 istek)

REDIS:
- Average Response Time: 42 ms
- Throughput: 238.5/sec
- Error %: 0%

HAZELCAST (Default Serialization):
- Average Response Time: 89 ms
- Throughput: 112.3/sec
- Error %: 0%

HAZELCAST (Kryo Serialization):
- Average Response Time: 38 ms
- Throughput: 263.1/sec
- Error %: 0%
        </div>
        <p class="tool-tip">ğŸ’¡ IntelliJ IDEA Ultimate: JMeter entegrasyonu ile doÄŸrudan IDE iÃ§inden test senaryolarÄ± Ã§alÄ±ÅŸtÄ±rÄ±labilir ve sonuÃ§lar grafiksel olarak analiz edilebilir.</p>
    </div>

    <div class="important">
        <strong>â— SonuÃ§ Vurgusu:</strong> 
        <p>Serialization stratejisi, distributed cache performansÄ±nda kritik rol oynar. Kryo kullanÄ±mÄ± ile Hazelcast, Redisâ€™i geÃ§ebilir. Ancak Redis daha basit, stabil ve dÃ¼ÅŸÃ¼k latency garantisi verir. SeÃ§im, veri yapÄ±sÄ± ve kullanÄ±m senaryosuna gÃ¶re yapÄ±lmalÄ±dÄ±r.</p>
    </div>

    <div class="performance-impact">
        <strong>âš¡ Genel Performans KazanÄ±mÄ±:</strong> 
        <p>DoÄŸru cache stratejisi + doÄŸru serialization + doÄŸru eviction policy ile:</p>
        <ul>
            <li>Response time: 200ms â†’ 40ms (%80 iyileÅŸme)</li>
            <li>DB yÃ¼kÃ¼: %70 azalma</li>
            <li>GC sÃ¼resi: %40 azalma (cache hit ratio artÄ±ÅŸÄ± sayesinde)</li>
            <li>Scale-out maliyeti: %50 azalma (daha az instance ile aynÄ± performans)</li>
        </ul>
    </div>

</body>
</html>