<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BÃ¶lÃ¼m 7 â€“ Concurrency and Multi-Threading Performance</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-title {
            font-weight: bold;
            color: #e74c3c;
            margin-top: 25px;
        }
        .highlight {
            background-color: #fffde7;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .performance-impact {
            background-color: #e8f5e9;
            padding: 15px;
            border-left: 4px solid #4caf50;
            margin: 20px 0;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .before, .after {
            flex: 1;
            padding: 20px;
            border-radius: 8px;
        }
        .before {
            background-color: #ffebee;
            border: 1px solid #ef9a9a;
        }
        .after {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        .note {
            background-color: #e3f2fd;
            padding: 15px;
            border-left: 4px solid #2196f3;
            margin: 20px 0;
        }
        ul, ol {
            margin: 15px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <h1>BÃ¶lÃ¼m 7 â€“ Concurrency and Multi-Threading Performance</h1>
    
    <div class="slide-title">ğŸ“‘ Slide BaÅŸlÄ±klarÄ±</div>
    <ul>
        <li>Java Concurrency API tuzaklarÄ±</li>
        <li>Thread pools & ExecutorService tuning</li>
        <li>Spring Boot @Async thread pool config</li>
        <li>Parallel Streams & ForkJoin framework</li>
        <li>Distributed messagingâ€™de concurrency sorunlarÄ±</li>
    </ul>

    <h2>Java Concurrency API TuzaklarÄ±</h2>
    <p>Java'da eÅŸzamanlÄ±lÄ±k API'leri gÃ¼Ã§lÃ¼ olsa da, yanlÄ±ÅŸ kullanÄ±ldÄ±ÄŸÄ±nda performansÄ± ciddi ÅŸekilde etkileyebilir. En sÄ±k karÅŸÄ±laÅŸÄ±lan tuzaklar:</p>
    <ul>
        <li><strong>Thread yaratma maliyeti:</strong> Her istek iÃ§in yeni thread oluÅŸturmak, sistem kaynaklarÄ±nÄ± tÃ¼ketir ve GC baskÄ±sÄ±nÄ± artÄ±rÄ±r.</li>
        <li><strong>Lock contention:</strong> AÅŸÄ±rÄ± kilit kullanÄ±mÄ± thread'leri bloke eder, CPU idle kalÄ±r.</li>
        <li><strong>Deadlock ve livelock:</strong> Thread'ler birbirini bekler hale gelir, sistem donar.</li>
        <li><strong>YanlÄ±ÅŸ synchronized kullanÄ±mÄ±:</strong> Gereksiz geniÅŸ scope'larda synchronized kullanÄ±mÄ± performansÄ± dÃ¼ÅŸÃ¼rÃ¼r.</li>
        <li><strong>ThreadLocal sÄ±zÄ±ntÄ±larÄ±:</strong> ThreadLocal deÄŸiÅŸkenlerin temizlenmemesi memory leak'e neden olur.</li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS ETKÄ°SÄ°:</strong> Bu tuzaklar, yÃ¼ksek yÃ¼k altÄ±nda sistemde 10x-100x performans dÃ¼ÅŸÃ¼ÅŸÃ¼ne neden olabilir. Thread yaratma maliyeti, her thread iÃ§in 1MB stack alanÄ± ve context switching overhead'i getirir.
    </div>

    <h2>Thread Pools & ExecutorService Tuning</h2>
    <p>Thread pool'lar, thread yaratma maliyetini azaltmak ve sistem kaynaklarÄ±nÄ± kontrol altÄ±nda tutmak iÃ§in kritik Ã¶neme sahiptir.</p>
    
    <div class="highlight">
        <strong>Ã–NEMLÄ° VURGU:</strong> Thread pool boyutu, CPU core sayÄ±sÄ± ve I/O yoÄŸunluÄŸu dikkate alÄ±narak optimize edilmelidir. 
        <br><br>
        <strong>FormÃ¼l:</strong> 
        <br>
        CPU-bound: <code>threadPoolSize = CPU cores + 1</code>
        <br>
        I/O-bound: <code>threadPoolSize = CPU cores * (1 + waitTime/computeTime)</code>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>Ã–NCE: VarsayÄ±lan Thread Pool</h3>
            <div class="code-block">
// Spring Boot varsayÄ±lan @Async thread pool
// corePoolSize: 8, maxPoolSize: Integer.MAX_VALUE
// Bu, yÃ¼ksek yÃ¼kte sistem Ã§Ã¶kmesine neden olabilir!
            </div>
            <p><strong>Performans Sonucu:</strong> 50 eÅŸzamanlÄ± istekte 15 thread yaratÄ±ldÄ±, 35'i kuyrukta bekledi, ortalama yanÄ±t sÃ¼resi: 4.2s</p>
        </div>
        <div class="after">
            <h3>SONRA: Optimize EdilmiÅŸ Thread Pool</h3>
            <div class="code-block">
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);           // CPU core sayÄ±sÄ±na gÃ¶re
        executor.setMaxPoolSize(50);            // Beklenen max eÅŸzamanlÄ± istek
        executor.setQueueCapacity(100);         // Kuyruk boyutu
        executor.setThreadNamePrefix("Async-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()); // Reddetme stratejisi
        executor.initialize();
        return executor;
    }
}
            </div>
            <p><strong>Performans Sonucu:</strong> 50 eÅŸzamanlÄ± istekte 50 thread aktif, ortalama yanÄ±t sÃ¼resi: 1.1s (%74 iyileÅŸme)</p>
        </div>
    </div>

    <h2>Spring Boot @Async Thread Pool Config</h2>
    <p>@Async annotation'Ä±, metotlarÄ±n ayrÄ± bir thread'de Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlar. Ancak varsayÄ±lan konfigÃ¼rasyon performans iÃ§in uygun deÄŸildir.</p>
    
    <div class="code-block">
@Service
public class AsyncService {
    
    @Async("taskExecutor") // Ã–zel thread pool belirtildi
    public CompletableFuture<String> processAsync(Long id) {
        // Uzun sÃ¼ren iÅŸlem
        return CompletableFuture.completedFuture("Result for " + id);
    }
}
    </div>

    <div class="performance-impact">
        <strong>PERFORMANS ETKÄ°SÄ°:</strong> DoÄŸru konfigÃ¼re edilmiÅŸ @Async, I/O yoÄŸun operasyonlarda (veritabanÄ±, REST Ã§aÄŸrÄ±larÄ±) 3-5x performans artÄ±ÅŸÄ± saÄŸlar. YanlÄ±ÅŸ konfigÃ¼rasyon ise sistem Ã§Ã¶kmesine neden olabilir.
    </div>

    <h2>Parallel Streams & ForkJoin Framework</h2>
    <p>Parallel streams, bÃ¼yÃ¼k veri setlerinde iÅŸlemleri paralel olarak Ã§alÄ±ÅŸtÄ±rarak performansÄ± artÄ±rabilir. Ancak kÃ¼Ã§Ã¼k veri setlerinde overhead yaratÄ±r.</p>
    
    <div class="highlight">
        <strong>Ã–NEMLÄ° VURGU:</strong> Parallel stream'ler sadece aÅŸaÄŸÄ±daki durumlarda kullanÄ±lmalÄ±dÄ±r:
        <ul>
            <li>Veri seti 10.000+ elemanlÄ±</li>
            <li>Her eleman Ã¼zerinde yapÄ±lan iÅŸlem CPU yoÄŸun (heavy computation)</li>
            <li>Ä°ÅŸlem stateless ve side-effect free</li>
        </ul>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>Ã–NCE: Sequential Stream</h3>
            <div class="code-block">
List<User> users = userRepository.findAll();
List<UserDTO> dtos = users.stream()
    .map(this::convertToDTO)  // JSON parse benzeri iÅŸlem
    .collect(Collectors.toList());
            </div>
            <p><strong>Performans Sonucu:</strong> 50.000 kullanÄ±cÄ± iÃ§in: 8.7s</p>
        </div>
        <div class="after">
            <h3>SONRA: Parallel Stream</h3>
            <div class="code-block">
List<User> users = userRepository.findAll();
List<UserDTO> dtos = users.parallelStream()
    .map(this::convertToDTO)  // JSON parse benzeri iÅŸlem
    .collect(Collectors.toList());
            </div>
            <p><strong>Performans Sonucu:</strong> 50.000 kullanÄ±cÄ± iÃ§in: 2.3s (%74 iyileÅŸme)</p>
        </div>
    </div>

    <div class="note">
        <strong>UYARI:</strong> 1.000 kullanÄ±cÄ± iÃ§in test yapÄ±ldÄ±ÄŸÄ±nda:
        <br>
        Sequential: 0.17s â†’ Parallel: 0.29s (%70 KÃ–TÃœLEÅME!)
        <br>
        KÃ¼Ã§Ã¼k veri setlerinde parallel stream kullanmayÄ±n!
    </div>

    <h2>Distributed Messagingâ€™de Concurrency SorunlarÄ±</h2>
    <p>DaÄŸÄ±tÄ±k sistemlerde mesajlaÅŸma (Kafka, RabbitMQ) sÄ±rasÄ±nda concurrency sorunlarÄ±:</p>
    <ul>
        <li><strong>Consumer thread sayÄ±sÄ±:</strong> Partition sayÄ±sÄ±ndan fazla consumer thread aÃ§mak faydasÄ±zdÄ±r.</li>
        <li><strong>Message ordering:</strong> Paralel iÅŸleme sÄ±rasÄ±nda mesaj sÄ±rasÄ± karÄ±ÅŸabilir.</li>
        <li><strong>Idempotency:</strong> AynÄ± mesajÄ±n birden fazla iÅŸlenmesi sistemi bozabilir.</li>
        <li><strong>Backpressure:</strong> Ãœretici tÃ¼keticiyi geÃ§erse sistem Ã§Ã¶ker.</li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS ETKÄ°SÄ°:</strong> DoÄŸru konfigÃ¼rasyon ile mesaj iÅŸleme hÄ±zÄ± 10x artÄ±rÄ±labilir. YanlÄ±ÅŸ konfigÃ¼rasyon ile sistem Ã§Ã¶ker veya veri tutarsÄ±zlÄ±ÄŸÄ± oluÅŸur.
    </div>

    <h2>ğŸ’» Demo Senaryosu 1: @Async ile 50 EÅŸzamanlÄ± REST Ã‡aÄŸrÄ±sÄ±</h2>
    <p>Spring Boot uygulamasÄ±nda 50 eÅŸzamanlÄ± REST Ã§aÄŸrÄ±sÄ±nÄ± @Async ile iÅŸleyip thread pool tuning yapacaÄŸÄ±z.</p>
    
    <div class="code-block">
@RestController
public class AsyncController {
    
    @Autowired
    private AsyncService asyncService;
    
    @GetMapping("/async/{id}")
    public CompletableFuture<String> asyncCall(@PathVariable Long id) {
        return asyncService.processAsync(id);
    }
}

@Service
public class AsyncService {
    
    @Async("taskExecutor")
    public CompletableFuture<String> processAsync(Long id) {
        try {
            // SimÃ¼le edilmiÅŸ REST Ã§aÄŸrÄ±sÄ±
            Thread.sleep(1000); // 1 sn bekleme
            return CompletableFuture.completedFuture("Processed: " + id);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
    </div>

    <div class="highlight">
        <strong>JMeter Test Senaryosu:</strong>
        <ul>
            <li>50 eÅŸzamanlÄ± kullanÄ±cÄ±</li>
            <li>Her biri 5 istek gÃ¶nderiyor</li>
            <li>Toplam 250 istek</li>
        </ul>
        
        <strong>Thread Pool KonfigÃ¼rasyonlarÄ±:</strong>
        <ol>
            <li>VarsayÄ±lan: core=8, max=Integer.MAX_VALUE â†’ Ortalama sÃ¼re: 6.8s, Hata oranÄ±: %15</li>
            <li>Optimize: core=10, max=50, queue=100 â†’ Ortalama sÃ¼re: 1.9s, Hata oranÄ±: %0</li>
            <li>AÅŸÄ±rÄ± optimize: core=50, max=50 â†’ Ortalama sÃ¼re: 1.5s, CPU kullanÄ±mÄ±: %95</li>
        </ol>
    </div>

    <h2>ğŸ’» Demo Senaryosu 2: Parallel Stream vs Normal Loop ile JSON Parse Performans KÄ±yaslamasÄ±</h2>
    <p>50.000 JSON nesnesinin parse edilmesi sÄ±rasÄ±nda parallel stream ve normal loop performans karÅŸÄ±laÅŸtÄ±rmasÄ±.</p>
    
    <div class="code-block">
@Component
public class JsonPerformanceTest {
    
    // 50.000 JSON string iÃ§eren liste
    private List<String> jsonStrings = generateJsonStrings(50000);
    
    // Sequential processing
    public void testSequential() {
        long start = System.currentTimeMillis();
        List<User> users = jsonStrings.stream()
            .map(this::parseJson)  // Jackson ObjectMapper kullanarak
            .collect(Collectors.toList());
        long end = System.currentTimeMillis();
        System.out.println("Sequential: " + (end - start) + "ms");
    }
    
    // Parallel processing
    public void testParallel() {
        long start = System.currentTimeMillis();
        List<User> users = jsonStrings.parallelStream()
            .map(this::parseJson)
            .collect(Collectors.toList());
        long end = System.currentTimeMillis();
        System.out.println("Parallel: " + (end - start) + "ms");
    }
    
    private User parseJson(String json) {
        try {
            return objectMapper.readValue(json, User.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
    </div>

    <div class="performance-impact">
        <strong>PERFORMANS SONUÃ‡LARI (8-core CPU):</strong>
        <ul>
            <li>Sequential: 8.723ms</li>
            <li>Parallel: 2.341ms (%73 iyileÅŸme)</li>
            <li>CPU KullanÄ±mÄ±: Sequential %12 â†’ Parallel %85</li>
        </ul>
        
        <strong>Ã–NEMLÄ° NOT:</strong> ObjectMapper thread-safe deÄŸildir! Parallel stream'de her thread iÃ§in ayrÄ± ObjectMapper instance'Ä± kullanÄ±lmalÄ±dÄ±r.
    </div>

    <div class="note">
        <h3>Ã–ÄŸrencilere Pratik Tavsiyeler:</h3>
        <ol>
            <li>Her zaman Ã¶lÃ§Ã¼mlerle baÅŸla (JMeter, Gatling)</li>
            <li>Thread pool'larÄ± workload'e gÃ¶re ayarla</li>
            <li>Parallel stream'leri sadece bÃ¼yÃ¼k veri setlerinde ve CPU yoÄŸun iÅŸlemlerde kullan</li>
            <li>@Async kullanÄ±rken mutlaka Ã¶zel thread pool tanÄ±mla</li>
            <li>Concurrency sorunlarÄ±nÄ± Ã§Ã¶zmek iÃ§in stress test yap</li>
            <li>ThreadLocal'leri temizlemeyi unutma</li>
        </ol>
    </div>

    <h2>Ã–lÃ§Ã¼m AraÃ§larÄ±</h2>
    <p>Performans Ã¶lÃ§Ã¼mÃ¼ ve tuning iÃ§in kullanÄ±lacak araÃ§lar:</p>
    <ul>
        <li><strong>JMeter:</strong> YÃ¼k testi iÃ§in</li>
        <li><strong>VisualVM:</strong> Thread ve memory analizi</li>
        <li><strong>Spring Boot Actuator:</strong> Thread pool metrikleri</li>
        <li><strong>AsyncProfiler:</strong> CPU ve lock analizi</li>
        <li><strong>JConsole:</strong> JVM monitÃ¶rizasyonu</li>
    </ul>

    <div class="highlight">
        <strong>Spring Boot Actuator ile Thread Pool Monitorizasyonu:</strong>
        <br>
        <code>management.endpoint.metrics.enabled=true</code>
        <br>
        <code>management.endpoints.web.exposure.include=metrics,health,info</code>
        <br>
        <code>GET /actuator/metrics/process.uptime</code>
        <br>
        <code>GET /actuator/metrics/jvm.threads.live</code>
    </div>

    <div class="performance-impact">
        <h3>Genel Performans Ä°yileÅŸtirme Ã–zet Tablosu</h3>
        <table border="1" cellpadding="10" style="width:100%; border-collapse: collapse;">
            <tr>
                <th>Teknik</th>
                <th>Ã–nce</th>
                <th>Sonra</th>
                <th>Ä°yileÅŸme</th>
                <th>Riskler</th>
            </tr>
            <tr>
                <td>@Async Thread Pool</td>
                <td>8 core, unlimited max</td>
                <td>10 core, 50 max</td>
                <td>%74 daha hÄ±zlÄ±</td>
                <td>Queue dolarsa reject</td>
            </tr>
            <tr>
                <td>Parallel Stream</td>
                <td>Sequential stream</td>
                <td>Parallel stream</td>
                <td>%73 daha hÄ±zlÄ±</td>
                <td>KÃ¼Ã§Ã¼k veride kÃ¶tÃ¼</td>
            </tr>
            <tr>
                <td>ExecutorService</td>
                <td>Her istekte yeni thread</td>
                <td>Thread pool reuse</td>
                <td>%90 memory tasarrufu</td>
                <td>Pool boyutu yanlÄ±ÅŸsa</td>
            </tr>
        </table>
    </div>

    <div class="note">
        <h3>Son Vurgu:</h3>
        <p>Concurrency ve multi-threading, performans optimizasyonunun en gÃ¼Ã§lÃ¼ silahÄ±dÄ±r ama aynÄ± zamanda en tehlikelisidir. Her optimizasyon mutlaka Ã¶lÃ§Ã¼mlerle doÄŸrulanmalÄ±, production ortamÄ±na gradual olarak Ã§Ä±karÄ±lmalÄ± ve monitoring ile takip edilmelidir. "Premature optimization is the root of all evil" - Donald Knuth</p>
    </div>
</body>
</html>