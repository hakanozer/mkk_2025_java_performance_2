<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimized Java Development - Java & Spring Boot Code Optimization Tips</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        h3 {
            color: #e74c3c;
        }
        .slide-title {
            background-color: #3498db;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 25px 0 20px 0;
            font-size: 1.4em;
        }
        .highlight {
            background-color: #fffde7;
            padding: 15px;
            border-left: 4px solid #ffd600;
            margin: 15px 0;
        }
        .performance-tip {
            background-color: #e8f5e9;
            padding: 15px;
            border-left: 4px solid #4caf50;
            margin: 15px 0;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 25px 0;
        }
        .before, .after {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
        }
        .before {
            background-color: #ffebee;
            border: 1px solid #ffcdd2;
        }
        .after {
            background-color: #e8f5e9;
            border: 1px solid #c8e6c9;
        }
        .before h4, .after h4 {
            margin-top: 0;
            color: #d32f2f;
        }
        .after h4 {
            color: #388e3c;
        }
        code {
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95em;
        }
        pre {
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        .demo-section {
            background-color: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
            border: 2px dashed #2196f3;
        }
        .note {
            background-color: #fff3e0;
            padding: 15px;
            border-left: 4px solid #ffb74d;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>

<h1>Performance Optimized Java Development</h1>
<h2>8 â€“ Java & Spring Boot Code Optimization Tips</h2>

<div class="slide-title">ğŸ“‘ Java Core Optimizasyonlar</div>

<h3>String Concatenation</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Geleneksel "+" operatÃ¶rÃ¼ ile string birleÅŸtirme, her birleÅŸtirme iÅŸleminde yeni String nesnesi oluÅŸturur. BÃ¼yÃ¼k veri setlerinde bu, gereksiz bellek tÃ¼ketimi ve GC (Garbage Collection) baskÄ±sÄ± yaratÄ±r.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k)</h4>
        <pre><code>public String buildReport(List<String> items) {
    String result = "";
    for (String item : items) {
        result += item + "\n"; // Her dÃ¶ngÃ¼de yeni String nesnesi!
    }
    return result;
}</code></pre>
        <p><strong>GC Etkisi:</strong> 10.000 eleman iÃ§in ~10.000 geÃ§ici String nesnesi</p>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek)</h4>
        <pre><code>public String buildReport(List<String> items) {
    StringBuilder sb = new StringBuilder();
    for (String item : items) {
        sb.append(item).append("\n");
    }
    return sb.toString();
}</code></pre>
        <p><strong>GC Etkisi:</strong> Sadece 1 StringBuilder + 1 sonuÃ§ String nesnesi</p>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> 10.000+ iterasyonlarda StringBuilder, "+" operatÃ¶rÃ¼ne gÃ¶re 100x-300x daha hÄ±zlÄ± Ã§alÄ±ÅŸabilir. GC baskÄ±sÄ± neredeyse sÄ±fÄ±ra iner.
</div>

<h3>Primitive vs Wrapper</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Wrapper sÄ±nÄ±flar (Integer, Long vs.) boxing/unboxing maliyeti getirir. Ã–zellikle yoÄŸun dÃ¶ngÃ¼lerde bu maliyet kritik olur.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k)</h4>
        <pre><code>public void processNumbers(List<Integer> numbers) {
    Integer sum = 0; // Boxing
    for (Integer num : numbers) {
        sum = sum + num; // Unboxing + Boxing
    }
}</code></pre>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek)</h4>
        <pre><code>public void processNumbers(int[] numbers) {
    int sum = 0; // Primitive - zero overhead
    for (int num : numbers) {
        sum += num;
    }
}</code></pre>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> Primitive tipler, Wrapper'lara gÃ¶re 2-5x daha hÄ±zlÄ±dÄ±r. AyrÄ±ca memory footprint %50-70 daha dÃ¼ÅŸÃ¼ktÃ¼r.
</div>

<h3>BigDecimal KullanÄ±mÄ±</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> BigDecimal, hassas hesaplamalar iÃ§in gerekli olsa da, double'a gÃ¶re 10-100x daha yavaÅŸtÄ±r. Gereksiz kullanÄ±m performansÄ± ciddi ÅŸekilde etkiler.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k)</h4>
        <pre><code>// Para birimi olmayan hesaplamalarda BigDecimal kullanÄ±mÄ±
BigDecimal total = BigDecimal.ZERO;
for (Product p : products) {
    total = total.add(new BigDecimal(p.getPrice())); // AÅŸÄ±rÄ± maliyetli
}</code></pre>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek)</h4>
        <pre><code>// Hassasiyet gerekmiyorsa double kullan
double total = 0.0;
for (Product p : products) {
    total += p.getPrice(); // CPU native iÅŸlem
}

// Para birimi iÃ§inse cent cinsinden long kullan
long totalCents = 0;
for (Product p : products) {
    totalCents += Math.round(p.getPrice() * 100); // Long aritmetiÄŸi
}</code></pre>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> BigDecimal, finansal iÅŸlemler dÄ±ÅŸÄ±nda kullanÄ±lmamalÄ±. Basit aritmetik iÅŸlemlerde double veya long kullanÄ±mÄ± 50x performans artÄ±ÅŸÄ± saÄŸlar.
</div>

<h3>Gereksiz Object Creation</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Her istekte yeni nesne oluÅŸturmak, GC'yi tetikler ve CPU zamanÄ±nÄ± tÃ¼ketir. Ã–zellikle yÃ¼ksek trafikli sistemlerde kritik darboÄŸaz yaratÄ±r.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k)</h4>
        <pre><code>@Service
public class ReportService {
    public String generateReport() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); // Her Ã§aÄŸrÄ±da yeni nesne!
        return sdf.format(new Date());
    }
}</code></pre>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek)</h4>
        <pre><code>@Service
public class ReportService {
    private static final DateTimeFormatter FORMATTER = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd"); // Tek seferde oluÅŸturulur

    public String generateReport() {
        return LocalDate.now().format(FORMATTER);
    }
}</code></pre>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> Thread-safe immutable nesneleri static final olarak tanÄ±mlamak, nesne oluÅŸturma maliyetini %100 azaltÄ±r ve GC baskÄ±sÄ±nÄ± ortadan kaldÄ±rÄ±r.
</div>

<div class="slide-title">ğŸ“‘ Spring Boot API Optimizasyonlar</div>

<h3>N+1 Problem Ã‡Ã¶zÃ¼mÃ¼ (Spring Data JPA + Fetch Join)</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> N+1 problemi, 1 ana sorgu + N alt sorgu anlamÄ±na gelir. 100 kayÄ±t iÃ§in 101 veritabanÄ± sorgusu! Bu, aÄŸ gecikmesi ve DB yÃ¼kÃ¼ aÃ§Ä±sÄ±ndan felakettir.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k - N+1)</h4>
        <pre><code>@Entity
public class Order {
    @Id private Long id;
    @OneToMany(mappedBy = "order")
    private List<OrderItem> items; // LAZY loaded
}

// Controller
@GetMapping("/orders")
public List<Order> getOrders() {
    return orderRepository.findAll(); // 1 sorgu
}

// JSON serialization sÄ±rasÄ±nda her Order iÃ§in items lazy load edilir â†’ N sorgu!
</code></pre>
        <p><strong>DB SorgularÄ±:</strong> 1 (Order) + N (OrderItem) = N+1</p>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek - Fetch Join)</h4>
        <pre><code>@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("SELECT DISTINCT o FROM Order o JOIN FETCH o.items")
    List<Order> findAllWithItems(); // Tek sorguda hepsi
}

// Veya EntityGraph ile
@NamedEntityGraph(name = "Order.withItems", 
    attributeNodes = @NamedAttributeNode("items"))
public class Order { ... }

// Repository
@EntityGraph("Order.withItems")
List<Order> findAll();
</code></pre>
        <p><strong>DB SorgularÄ±:</strong> 1 (JOIN ile tek sorgu)</p>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> 100 kayÄ±t iÃ§in N+1 problemi 101 sorgu â†’ 1 sorguya indirilir. Ortalama yanÄ±t sÃ¼resi 500ms'den 50ms'ye dÃ¼ÅŸer (%90 iyileÅŸme).
</div>

<h3>DTO Mapping Optimizasyonu (MapStruct vs ModelMapper)</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Reflection tabanlÄ± mapper'lar (ModelMapper) Ã§alÄ±ÅŸma zamanÄ±nda reflection kullanÄ±r. Derleme zamanÄ±nda kod Ã¼reten mapper'lar (MapStruct) native Java kodu Ã¼retir.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k - ModelMapper)</h4>
        <pre><code>@Service
public class ProductService {
    private ModelMapper modelMapper = new ModelMapper();
    
    public ProductDTO toDTO(Product product) {
        return modelMapper.map(product, ProductDTO.class); // Runtime reflection!
    }
}</code></pre>
        <p><strong>Performans:</strong> ~10.000 mapping/sn, yÃ¼ksek CPU kullanÄ±mÄ±</p>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek - MapStruct)</h4>
        <pre><code>@Mapper(componentModel = "spring")
public interface ProductMapper {
    ProductMapper INSTANCE = Mappers.getMapper(ProductMapper.class);
    
    ProductDTO toDTO(Product product); // Compile-time generated code
}

// Ãœretilen kod (derleme zamanÄ±nda):
// public class ProductMapperImpl implements ProductMapper {
//     public ProductDTO toDTO(Product product) {
//         if (product == null) return null;
//         ProductDTO dto = new ProductDTO();
//         dto.setId(product.getId()); // Direct field access - zero reflection
//         dto.setName(product.getName());
//         return dto;
//     }
// }</code></pre>
        <p><strong>Performans:</strong> ~1.500.000 mapping/sn, dÃ¼ÅŸÃ¼k CPU kullanÄ±mÄ±</p>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> MapStruct, ModelMapper'a gÃ¶re 50-150x daha hÄ±zlÄ±dÄ±r. Reflection maliyeti ortadan kalkar, CPU cache locality iyileÅŸir.
</div>

<h3>Logging Best Practices (Async Logging)</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Senkron loglama, disk I/O bekleme sÃ¼resince thread'leri bloke eder. Async loglama, loglarÄ± ayrÄ± bir thread'de iÅŸler ve ana thread'leri serbest bÄ±rakÄ±r.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k - Senkron)</h4>
        <pre><code># logback-spring.xml (default - synchronous)
<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>app.log</file>
    <encoder>
        <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
    </encoder>
</appender>

// Her log Ã§aÄŸrÄ±sÄ± disk I/O bekler!
logger.info("User {} logged in", userId);</code></pre>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek - Async)</h4>
        <pre><code># logback-spring.xml (async)
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="FILE"/>
    <queueSize>512</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <includeCallerData>false</includeCallerData>
</appender>

# application.properties
logging.pattern.console=%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

// Log Ã§aÄŸrÄ±sÄ± hemen dÃ¶nÃ¼yor, I/O async thread'de yapÄ±lÄ±yor</code></pre>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> Async logging, yÃ¼ksek trafikli sistemlerde request sÃ¼relerini %30-70 azaltabilir. Thread'ler I/O beklemek yerine iÅŸ yapmaya devam eder.
</div>

<h3>PreparedStatement KullanÄ±mÄ±</h3>
<div class="highlight">
    <strong>Performansa Etkisi:</strong> Statement yerine PreparedStatement kullanÄ±mÄ±, SQL injection korumasÄ± saÄŸlamanÄ±n yanÄ± sÄ±ra, DB'nin sorgu planÄ±nÄ± Ã¶nbelleÄŸe almasÄ±na izin verir.
</div>

<div class="before-after">
    <div class="before">
        <h4>Ã–NCE (Performans DÃ¼ÅŸÃ¼k - Statement)</h4>
        <pre><code>String sql = "SELECT * FROM users WHERE name = '" + name + "'"; // SQL Injection riski!
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(sql); // Her seferde yeni parse + plan</code></pre>
        <p><strong>DB YÃ¼kÃ¼:</strong> Her sorgu iÃ§in yeni parse ve execution plan</p>
    </div>
    <div class="after">
        <h4>SONRA (Performans YÃ¼ksek - PreparedStatement)</h4>
        <pre><code>String sql = "SELECT * FROM users WHERE name = ?";
PreparedStatement pstmt = connection.prepareStatement(sql);
pstmt.setString(1, name);
ResultSet rs = pstmt.executeQuery(); // Sorgu planÄ± Ã¶nbelleÄŸe alÄ±nÄ±r</code></pre>
        <p><strong>DB YÃ¼kÃ¼:</strong> Ä°lk Ã§alÄ±ÅŸtÄ±rmada parse + plan, sonrakilerde sadece execute</p>
    </div>
</div>

<div class="performance-tip">
    <strong>ğŸ“Œ Performans Vurgusu:</strong> PreparedStatement, aynÄ± sorgunun tekrar tekrar Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± durumunda %40-60 performans artÄ±ÅŸÄ± saÄŸlar. DB CPU ve memory kullanÄ±mÄ± dÃ¼ÅŸer.
</div>

<div class="demo-section">
    <h2>ğŸ’» Demo Senaryosu: Optimize EdilmemiÅŸ vs Optimize EdilmiÅŸ REST API</h2>
    
    <h3>JMeter Load Test ile KÄ±yaslamalar</h3>
    
    <table>
        <thead>
            <tr>
                <th>Metrik</th>
                <th>Optimize EdilmemiÅŸ API</th>
                <th>Optimize EdilmiÅŸ API</th>
                <th>Ä°yileÅŸme</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Ortalama YanÄ±t SÃ¼resi</td>
                <td>850 ms</td>
                <td>95 ms</td>
                <td>%89 daha hÄ±zlÄ±</td>
            </tr>
            <tr>
                <td>Ä°stek/Saniye (Throughput)</td>
                <td>120 req/sec</td>
                <td>1,150 req/sec</td>
                <td>%858 artÄ±ÅŸ</td>
            </tr>
            <tr>
                <td>GC SÃ¼resi (1 dk)</td>
                <td>4.2 saniye</td>
                <td>0.3 saniye</td>
                <td>%93 azalma</td>
            </tr>
            <tr>
                <td>DB Sorgu SayÄ±sÄ±</td>
                <td>101 sorgu (N+1)</td>
                <td>1 sorgu (Fetch Join)</td>
                <td>%99 azalma</td>
            </tr>
            <tr>
                <td>CPU KullanÄ±mÄ±</td>
                <td>85%</td>
                <td>35%</td>
                <td>%59 azalma</td>
            </tr>
        </tbody>
    </table>
    
    <h3>Spring Data JPA N+1 Problem Ã–rneÄŸi + Ã‡Ã¶zÃ¼m GÃ¶sterimi</h3>
    
    <div class="note">
        <strong>AdÄ±m 1:</strong> N+1 problemi teÅŸhis etmek iÃ§in Hibernate loglarÄ±nÄ± aÃ§Ä±n:
        <pre><code>logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE</code></pre>
    </div>
    
    <div class="note">
        <strong>AdÄ±m 2:</strong> N+1 problemi yaÅŸayan kodu gÃ¶zlemleyin (YukarÄ±daki "Ã–NCE" Ã¶rneÄŸi)
    </div>
    
    <div class="note">
        <strong>AdÄ±m 3:</strong> Fetch Join Ã§Ã¶zÃ¼mÃ¼nÃ¼ uygulayÄ±n (YukarÄ±daki "SONRA" Ã¶rneÄŸi)
    </div>
    
    <div class="note">
        <strong>AdÄ±m 4:</strong> JMeter ile karÅŸÄ±laÅŸtÄ±rmalÄ± test yapÄ±n:
        <ul>
            <li>Thread SayÄ±sÄ±: 100</li>
            <li>Ramp-Up: 10 saniye</li>
            <li>Loop Count: 100</li>
            <li>Toplam Ä°stek: 10.000</li>
        </ul>
    </div>
    
    <div class="performance-tip">
        <strong>ğŸ“Œ Demo Vurgusu:</strong> N+1 problemini Ã§Ã¶zmek tek baÅŸÄ±na, sistemin toplam performansÄ±nÄ± 8-10x artÄ±rabilir. Bu, en bÃ¼yÃ¼k kazanÄ±mlardan biridir!
    </div>
</div>

<div class="highlight">
    <h3>EÄÄ°TMEN NOTU Ã–ÄRENCÄ°LERE:</h3>
    <p>Performans optimizasyonu, "premature optimization" olmamalÄ±. Ã–nce profiling yapÄ±n, darboÄŸazlarÄ± tespit edin, sonra optimize edin. YukarÄ±daki tekniklerin her biri, doÄŸru kullanÄ±ldÄ±ÄŸÄ±nda sisteminizi katlanarak daha performanslÄ± hale getirecektir. UnutmayÄ±n: "Measure twice, cut once!"</p>
</div>

</body>
</html>