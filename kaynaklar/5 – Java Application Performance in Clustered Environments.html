<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BÃ¶lÃ¼m 5 â€“ Java Application Performance in Clustered Environments</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 8px 12px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-title {
            background-color: #2c3e50;
            color: white;
            padding: 12px;
            border-radius: 5px;
            margin: 25px 0 15px 0;
        }
        .important {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .performance-impact {
            background-color: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .before, .after {
            flex: 1;
            padding: 20px;
            border-radius: 8px;
        }
        .before {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        .after {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        .demo-section {
            background-color: #e8f4fc;
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
            border: 1px solid #b3d7ff;
        }
        .step {
            font-weight: bold;
            color: #2980b9;
        }
    </style>
</head>
<body>

<h1>BÃ¶lÃ¼m 5 â€“ Java Application Performance in Clustered Environments</h1>

<div class="slide-title">Clustered mimariler: Horizontal scaling, multiple JVM</div>

<p>Modern uygulamalar, yÃ¼ksek eriÅŸilebilirlik ve yÃ¼k dengeleme iÃ§in genellikle birden fazla JVM instance Ã¼zerinde Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Horizontal scaling, tek bir sunucunun kapasitesini aÅŸan yÃ¼kleri daÄŸÄ±tmak iÃ§in kritik bir stratejidir.</p>

<div class="important">
    <strong>Ã–NEMLÄ° VURGU:</strong> Birden fazla JVM Ã¼zerinde Ã§alÄ±ÅŸan bir uygulama, stateless (durumsuz) tasarlanmalÄ±dÄ±r. Aksi takdirde, session verileri veya shared state nedeniyle tutarsÄ±zlÄ±klar ve performans kayÄ±plarÄ± yaÅŸanÄ±r.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKÄ°SÄ°:</strong> Horizontal scaling, doÄŸru yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ±nda sistemin toplam kapasitesini doÄŸrusal olarak artÄ±rÄ±r. Ancak stateful (durumlu) yapÄ±lar, network hop'larÄ± ve veri eÅŸitleme maliyetleri nedeniyle Ã¶lÃ§eklenebilirliÄŸi bozar ve gecikmeyi artÄ±rÄ±r.
</div>

<div class="before-after">
    <div class="before">
        <h3>Ã–NCE: Tek Instance (Monolitik)</h3>
        <ul>
            <li>TÃ¼m kullanÄ±cÄ±lar tek JVM Ã¼zerinde servis edilir.</li>
            <li>Session verisi bellekte tutulur (in-memory).</li>
            <li>YÃ¼k arttÄ±ÄŸÄ±nda JVM GC baskÄ±sÄ± ve thread rekabeti artar.</li>
            <li>Failover yoktur â€” tek nokta hata riski yÃ¼ksektir.</li>
            <li><strong>Performans:</strong> YÃ¼ksek trafikte yanÄ±t sÃ¼releri katlanarak artar, hizmet kesintisi riski.</li>
        </ul>
    </div>
    <div class="after">
        <h3>SONRA: Ã‡oklu Instance (Clustered)</h3>
        <ul>
            <li>YÃ¼k dengeleyici (Load Balancer) gelen istekleri daÄŸÄ±tÄ±r.</li>
            <li>Her instance stateless â€” session verisi merkezi bir depoda tutulur.</li>
            <li>Failover mekanizmasÄ± â€” bir instance Ã§Ã¶kerse diÄŸerleri devreye girer.</li>
            <li><strong>Performans:</strong> Trafik artsa bile yanÄ±t sÃ¼releri sabit kalÄ±r, sistemin toplam kapasitesi artar.</li>
        </ul>
    </div>
</div>

<div class="slide-title">Session replication sorunlarÄ±</div>

<p>Geleneksel yaklaÅŸÄ±mlarda, session verisi bir instanceâ€™tan diÄŸerine Ã§oÄŸaltÄ±lÄ±r (replicate). Bu, network trafiÄŸi, bellek tÃ¼ketimi ve tutarlÄ±lÄ±k sorunlarÄ±na yol aÃ§ar.</p>

<div class="important">
    <strong>Ã–NEMLÄ° VURGU:</strong> Session replication, CAP teoremine gÃ¶re consistency ve availability arasÄ±nda bir Ã¶dÃ¼nleÅŸim zorunluluÄŸu yaratÄ±r. Ã–zellikle yÃ¼ksek trafikli sistemlerde network bottleneck oluÅŸturur.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKÄ°SÄ°:</strong> Session replication, her HTTP isteÄŸinden sonra network Ã¼zerinden veri senkronizasyonu gerektirir. Bu, latencyâ€™yi artÄ±rÄ±r ve Ã¶lÃ§eklenebilirliÄŸi sÄ±nÄ±rlar. BÃ¼yÃ¼k session verileri durumunda etki katlanarak artar.
</div>

<div class="before-after">
    <div class="before">
        <h3>Ã–NCE: Session Replication</h3>
        <ul>
            <li>Her instance, diÄŸerlerinin session verisini tutar.</li>
            <li>Session gÃ¼ncellendiÄŸinde tÃ¼m nodeâ€™lara broadcast yapÄ±lÄ±r.</li>
            <li>Network trafiÄŸi ve CPU kullanÄ±mÄ± yÃ¼ksek.</li>
            <li>TutarlÄ±lÄ±k sorunlarÄ± (eventual consistency).</li>
            <li><strong>Performans:</strong> 1000 kullanÄ±cÄ±da 300ms gecikme â†’ 10.000 kullanÄ±cÄ±da 2500ms gecikme.</li>
        </ul>
    </div>
    <div class="after">
        <h3>SONRA: External Session Store (Redis)</h3>
        <ul>
            <li>Session verisi Redis gibi harici bir key-value storeâ€™da tutulur.</li>
            <li>Her instance sadece gerektiÄŸinde session verisini okur/yazar.</li>
            <li>Network trafiÄŸi minimumda, sadece okuma/yazma iÅŸlemleri.</li>
            <li>Tek kaynaklÄ± tutarlÄ±lÄ±k (strong consistency).</li>
            <li><strong>Performans:</strong> 10.000 kullanÄ±cÄ±da bile ortalama 50-100ms yanÄ±t sÃ¼resi korunur.</li>
        </ul>
    </div>
</div>

<div class="slide-title">Distributed locks</div>

<p>Clustered ortamlarda, aynÄ± kaynaÄŸÄ± (Ã¶rneÄŸin: stok gÃ¼ncelleme, sÄ±ra numarasÄ± Ã¼retimi) birden fazla instance aynÄ± anda deÄŸiÅŸtirmeye Ã§alÄ±ÅŸabilir. Bu durumda race condition ve veri tutarsÄ±zlÄ±ÄŸÄ± riski doÄŸar. Distributed lock mekanizmalarÄ± bu sorunu Ã§Ã¶zer.</p>

<div class="important">
    <strong>Ã–NEMLÄ° VURGU:</strong> JVM iÃ§i (in-JVM) synchronized veya ReentrantLock yapÄ±larÄ± sadece tek JVM iÃ§inde Ã§alÄ±ÅŸÄ±r. Clustered ortamda geÃ§ersizdir. Mutlaka daÄŸÄ±tÄ±k kilit mekanizmasÄ± kullanÄ±lmalÄ±dÄ±r.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKÄ°SÄ°:</strong> Distributed lock, network Ã¼zerinden koordinasyon gerektirdiÄŸi iÃ§in ek gecikme yaratÄ±r. Ancak bu gecikme, veri tutarsÄ±zlÄ±ÄŸÄ±nÄ±n maliyetinden Ã§ok daha dÃ¼ÅŸÃ¼ktÃ¼r. Ä°yi tasarlanmÄ±ÅŸ lock scope ve TTL ile performans etkisi minimize edilebilir.
</div>

<div class="slide-title">Network latency problemleri</div>

<p>Clustered mimarilerde, instanceâ€™lar arasÄ± iletiÅŸim ve harici servislerle (Redis, DB, Cache) yapÄ±lan Ã§aÄŸrÄ±lar network gecikmesine (latency) maruz kalÄ±r. Bu gecikmeler, Ã¶zellikle yÃ¼ksek trafikte kÃ¼mÃ¼latif olarak sistemin genel performansÄ±nÄ± dÃ¼ÅŸÃ¼rÃ¼r.</p>

<div class="important">
    <strong>Ã–NEMLÄ° VURGU:</strong> Network latency, â€œbeklenenâ€ bir maliyettir ama optimize edilebilir. Connection pooling, async Ã§aÄŸrÄ±lar, cache Ã¶n bellekleme ve co-location (aynÄ± veri merkezinde deploy) gibi stratejilerle etkisi azaltÄ±labilir.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKÄ°SÄ°:</strong> Her Redis eriÅŸimi 2-5ms ekleyebilir. 10 adÄ±mlÄ± bir iÅŸ akÄ±ÅŸÄ±nda bu 20-50msâ€™e ulaÅŸabilir. Bu nedenle gereksiz Ã§aÄŸrÄ±lar minimize edilmeli, batch iÅŸlemleri tercih edilmelidir.
</div>

<div class="demo-section">
    <h2>ğŸ’» Demo Senaryosu: Spring Boot 3.5.5 + Redis Session + Redisson Distributed Lock</h2>
    <p><strong>Hedef:</strong> Ä°ki Spring Boot instanceâ€™Ä± aynÄ± kullanÄ±cÄ± sessionâ€™Ä±nÄ± paylaÅŸacak ve kritik bir kaynaÄŸÄ± distributed lock ile koruyacak.</p>

    <h3>AdÄ±m 1: Proje Kurulumu (IntelliJ IDEA Ultimate)</h3>
    <ul>
        <li>Spring Initializr ile yeni proje oluÅŸturun:
            <ul>
                <li>Spring Boot: 3.5.5</li>
                <li>Dependencies: Spring Web, Spring Session Data Redis, Spring Data Redis, Redisson</li>
            </ul>
        </li>
        <li><code>application.properties</code> dosyasÄ±nÄ± yapÄ±landÄ±rÄ±n:
            <div class="code-block">
server.port=8080
spring.redis.host=localhost
spring.redis.port=6379
spring.session.store-type=redis
spring.session.timeout=1800s
            </div>
        </li>
    </ul>

    <h3>AdÄ±m 2: RedisSession KonfigÃ¼rasyonu</h3>
    <p>Session verisinin Redisâ€™te saklanmasÄ±nÄ± saÄŸlar. Her iki instance da aynÄ± Redisâ€™e baÄŸlanacaÄŸÄ± iÃ§in session paylaÅŸÄ±mÄ± otomatik saÄŸlanÄ±r.</p>
    <div class="code-block">
@Configuration
@EnableRedisHttpSession
public class SessionConfig {
    @Bean
    public LettuceConnectionFactory connectionFactory() {
        return new LettuceConnectionFactory();
    }
}
    </div>

    <h3>AdÄ±m 3: Redisson Distributed Lock KonfigÃ¼rasyonu</h3>
    <div class="code-block">
@Configuration
public class RedissonConfig {
    
    @Value("${spring.redis.host}")
    private String redisHost;
    
    @Value("${spring.redis.port}")
    private int redisPort;

    @Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://" + redisHost + ":" + redisPort);
        return Redisson.create(config);
    }
}
    </div>

    <h3>AdÄ±m 4: Kritik KaynaÄŸa EriÅŸim (Distributed Lock Kullanarak)</h3>
    <div class="code-block">
@RestController
public class InventoryController {
    
    @Autowired
    private RedissonClient redissonClient;
    
    private int stock = 100; // paylaÅŸÄ±lan kaynak

    @PostMapping("/buy")
    public ResponseEntity<String> buyItem(@RequestBody PurchaseRequest request) {
        String lockKey = "inventory:lock:item:" + request.getItemId();
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            boolean acquired = lock.tryLock(3, 10, TimeUnit.SECONDS);
            if (!acquired) {
                return ResponseEntity.status(429).body("Too many requests, try again later");
            }
            
            // Kritik bÃ¶lge: stok kontrol ve gÃ¼ncelleme
            if (stock >= request.getQuantity()) {
                stock -= request.getQuantity();
                return ResponseEntity.ok("Purchase successful. Remaining stock: " + stock);
            } else {
                return ResponseEntity.badRequest().body("Insufficient stock");
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return ResponseEntity.status(500).body("Operation interrupted");
        } finally {
            lock.unlock();
        }
    }
}
    </div>

    <h3>AdÄ±m 5: Test ve GÃ¶zlem</h3>
    <ul>
        <li><span class="step">1.</span> Redis sunucusunu baÅŸlatÄ±n: <code>redis-server</code></li>
        <li><span class="step">2.</span> Projeyi iki farklÄ± portta Ã§alÄ±ÅŸtÄ±rÄ±n:
            <div class="code-block">
# Terminal 1
./gradlew bootRun --args='--server.port=8080'

# Terminal 2
./gradlew bootRun --args='--server.port=8081'
            </div>
        </li>
        <li><span class="step">3.</span> Postman veya curl ile aynÄ± kullanÄ±cÄ±yla iki instanceâ€™a login olun â€” sessionâ€™un Redisâ€™te tutulduÄŸunu ve her iki instanceâ€™ta da geÃ§erli olduÄŸunu gÃ¶zlemleyin.</li>
        <li><span class="step">4.</span> AynÄ± anda iki farklÄ± istemciden <code>POST /buy</code> Ã§aÄŸrÄ±sÄ± yapÄ±n â€” distributed lock sayesinde race condition olmadÄ±ÄŸÄ±nÄ±, stok tutarlÄ± kaldÄ±ÄŸÄ±nÄ± gÃ¶zlemleyin.</li>
        <li><span class="step">5.</span> Redis CLI ile session ve lock verilerini inceleyin:
            <div class="code-block">
redis-cli
KEYS *
HGETALL "spring:session:sessions:xxxx"
            </div>
        </li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS GÃ–ZLEMÄ°:</strong> Distributed lock olmadan 100 eÅŸzamanlÄ± istekte stok -50 gibi tutarsÄ±z bir deÄŸere dÃ¼ÅŸerken, distributed lock ile stok 0â€™dan aÅŸaÄŸÄ±ya inmez ve tutarlÄ± kalÄ±r. Eklenen ortalama gecikme: ~5ms.
    </div>
</div>

<div class="important">
    <strong>EÄÄ°TMEN NOTU:</strong> Clustered ortamlarda performans optimizasyonu, sadece kod deÄŸil, mimari kararlarla da saÄŸlanÄ±r. Session yÃ¶netimi, distributed lock, cache stratejileri ve network optimizasyonlarÄ± bu kararlarÄ±n en kritikleridir. Ã–ÄŸrencilerin â€œscale-outâ€ zihniyetini benimsemesi gerekir.
</div>

</body>
</html>